---
sidebar_position: 1
title: 前端基础-qa ⚡️
---

## var let const 区别：

1. `版本`： var 是 es6 之前， const、let es6 之后，
2. `分类`： 在 es6 之前只有`全局作用域`和`函数作用域`， const、let 块级作用域
3. `提升`：三者都会有变量提升，但是 let const 有暂时性死区，没执行到声明处，提前使用会报错
4. `重复`：var 可以重复声明、重复赋值，let 不可以重复声明，但可重复赋值，const 不可重复声明和赋值
5. `存储`：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的
6. `默认`： 默认情况下是 var 声明
7. `函数`：函数声明提升优先于 var

补充说明： const 和不变性。

1. const 创建一个变量名绑定，该绑定在创建后不能重新分配。
2. const 不创建不可变对象。不能更改绑定所引用的对象，但仍然可以更改对象的属性，这意味着使用 const 创建的绑定是可变的，而不是不可变的。

## 什么是执行上下文？

当 js 引擎执行到一段可执行代码时，就会为之创建对应的执行上下文(Execution Context)。分为三种：全局执行上下文，函数执行上下文，eval 执行上下文。

1. `全局上下文：`默认/基础的上下文，任何不在函数内部的代码都在全局上下文中，一个程序中只有一个全局执行上下文
2. `函数执行上下文`：一个函数被调用时，会为该函数创建一个上下文，每个函数都有自己的函数上下文，函数上下文可以有任意多个
3. `eval上下文`：执行在 eval 函数内部的代码也会有属于它自己的执行上下文

## javascript 的执行顺序

1. `JavaScript 代码在执行的过程中`，需要先做变量提升，之所以如此，是因为 JavaScript 代码在执行前需要进行`编译`；
2. 在编译阶段，
   1. 变量和函数会被存放到`变量环境`中，变量的默认值为 undefined；
   2. 块级作用域会被存放到`词法环境`中；
   3. 存在两个相同的函数，后面的会`覆盖`前面的函数；
3. 调用函数时，JavaScript 引擎维护了一个栈的数据结构（`调用栈`），每次调用函数都会将函数的执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码；
4. 当函数执行完毕后，JavaScript 引擎会将该函数的执行上下文`弹出栈`；
5. 当分配的栈空间被占满时，会引发`栈溢出`的情况；

作者：chicABoo
链接：https://juejin.cn/post/6965786039185047559
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 作用域

作用域是可访问变量的集合。

1. 全局作用域
2. 函数作用域
3. 块级作用域

JavaScript 变量生命周期

1. 局部变量在函数执行完毕后销毁。
2. 全局变量在页面关闭后销毁。

## 作用域链

1. 当执行一段代码时，JS 引擎首先在当前执行上下文中查找变量，
2. 如果找不到，会根据外部引用, 去对应的外部执行上下文查找变量，直到查找到最外层的全局执行上下文，
3. 从当前执行上下文到全局执行上下文，形成了一个链条，我们称为`作用域链`

简单来说：由于函数嵌套，一个变量在当前函数作用域找不到，会往上找，直到全局作用域，这种作用域嵌套的现象；由内向外，一层一层往上的链式规则，这就是作用域链

<a href="https://juejin.cn/post/7023259995219165214" target="_blank" >JavaScript 执行机制二（深入之闭包）</a>

## 词法作用域

1. 词法作用域是`由代码声明的位置决定的`，所以词法作用域`是静态作用域`，通过它`能预测代码在执行过程中如何查找标识`。
2. 对于代码中`存在块级作用域的情况`，`作用域链首先在词法环境中查找，没找到才会到变量环境中查找`

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bfb6a6ffe2147be9ce8dbcc60eb0de5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" />

## 闭包

在 JavaScript 中，根据词法作用域的规则，内部函数总能访问外部函数声明的变量，当通过调用外部函数返回内部函数时，即使外部函数执行完毕，内部函数引用外部函数的变量仍存在内存中，我们就把这些变量的集合称为闭包

### 那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？

1. 如果一个函数内有闭包，javascript 在执行这个函数时候，会预扫描内部函数是否有使用的 foo 函数中声明的变量；
2. 预扫描过程中，在内层函数 showName 中找到了外部函数 foo 中声明的变量 name，因此在 JavaScript 中判断这是一个闭包，
3. 此时会在堆中开辟一个空间创建 closure(foo)对象，将 name 值存到里面。
4. 而执行栈中的 foo 执行上下文中的 name 存的值是 closure(foo)的地址，因此当 foo 函数执行完成并销毁，name 值仍然存在堆的 closure(foo)的对象中，具体如下图所示：
5. <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22b437d4602e45379d9c9b4139817a24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" />

作者：chicABoo
链接：https://juejin.cn/post/7023259995219165214
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 闭包是如何回收的

1. 如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭。但如果这个变量之后不在使用，就会造成内存泄露
2. 如果引用闭包的函数是一个局部变量，等函数销毁后，在下一次执行垃圾回收时，判断闭包这块内容不再使用，那么 JavaScript 引擎的垃圾回收器就会回收这块内容

### 闭包使用原则

1. 如果该闭包会一直使用，那么它可以作为全局变量而存在；
2. 但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用

### 总结

1. `作用域链：`每个执行上下文都有一个指向外部的 outer，这个指向外部的引用 outer 在编译时就决定了，也就是说，根据声明的位置就能确定外部引用 outer，这就是词法作用域（静态作用域），它能预测代码执行过程中如何查找标识。通过它就能确定作用域链。
2. `闭包：`外部函数声明的变量，在内部函数中调用，当调用外部函数返回内部函数时，外部函数中声明的变量并不会随着外部函数执行完成而销毁，这些变量构成的集合就是外部函数的闭包。
3. `栈和堆空间：`基本数据类型是存在栈空间中的，引用数据类型是存在堆空间中的。`当形成闭包时，外部函数声明的变量存放在调用栈中，对于外部函数中的变量被内部函数所使用，在堆中就会创建一个 closure(函数名)的对象，用于存放闭包的变量集合，而外部函数中存的只是堆中的地址。所以说，当外部函数执行完成销毁时，JavaScript 引擎并不会回收堆中的地址。`
4. `正确使用闭包：`如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用。

作者：chicABoo
链接：https://juejin.cn/post/7023259995219165214
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 什么是作用域？

通俗点来讲就是：指变量的可使用范围

一般有三种作用域：全局作用域、函数作用域、块级作用域

1. `全局作用域`：声明的变量，全局可见
2. `函数作用域`：声明的变量在当前函数内部可见
3. `块级作用域`：{},条件语句，循环语句中

## 原型

### 什么是原型

在 js 面向对象编程的实现 中, 原型是一个 prototype 对象，用于表示类型之间的关系。每一个对象都与另一个对象相关联，那个关联的对象就称为原型

### 为什么使用原型

1. 原型对象的用途： 是为每个实例对象 “存储” 共享的方法和属性，它仅仅是一个普通对象而已。
2. 所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。

### 原型分类

显示原型和隐式原型

1. 显示原型： prototype 关键字标识
2. 隐式原型： `__proto__`表示
3. 一个构造函数显示原型 === 该构造函数一个实例的隐式原型 即： （构造函数.`prototype` === 构造函数实例.`__proto__`）

### 什么是原型链

1. 每个实例对象的`__proto__`​ 属性, 指向它的构造函数的原型对象（`prototype`）。
2. 该原型对象也有一个自己的原型对象（`__proto__`​），层层向上直到一个对象的原型对象为 `null`​。
3. 根据定义，`null`​ 没有原型，并作为这个原型链中的最后一个环节

简单来说，原型链是： 一个对象 找原型对象 的依据

<a href="https://www.51cto.com/article/718086.html" target="_blank" >见</a>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E6%80%A7%E8%83%BD:~:text=%E5%B9%B6%E4%BD%9C%E4%B8%BA%E8%BF%99%E4%B8%AA-,%E5%8E%9F%E5%9E%8B%E9%93%BE,-%E4%B8%AD%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA" target="_blank" >原型链</a>

### 创建对象的几种方式

1. 对象字面量
2. 构造函数
3. new 关键字
4. Object.create
5. class

#### 继承，原型链

当谈到继承时，JavaScript 只有一种结构：对象。

每个实例对象（object）都有一个私有属性（称之为 `__proto__`）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（`__proto__`），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节

#### 继承属性

JavaScript 对象是动态的属性“包”（指其自己的属性）。

1. JavaScript 对象有一个指向一个原型对象的链。
2. 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾

#### 继承方法

函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）

```js
var o = {
  a: 2,
  m: function () {
    return this.a + 1;
  },
};

console.log(o.m()); // 3
// 当调用 o.m 时，'this' 指向了 o.

var p = Object.create(o);
// p 是一个继承自 o 的对象

p.a = 4; // 创建 p 的自身属性 'a'
console.log(p.m()); // 5 // 属性屏蔽
// 调用 p.m 时，'this' 指向了 p
// 又因为 p 继承了 o 的 m 函数
// 所以，此时的 'this.a' 即 p.a，就是 p 的自身属性 'a'
```

#### 使用语法结构创建的对象

```js
var o = { a: 1 };

// o 这个对象继承了 Object.prototype 上面的所有属性
// o 自身没有名为 hasOwnProperty 的属性
// hasOwnProperty 是 Object.prototype 的属性
// 因此 o 继承了 Object.prototype 的 hasOwnProperty
// Object.prototype 的原型为 null
// 原型链如下：
// o ---> Object.prototype ---> null

var a = ['yo', 'whadup', '?'];

// 数组都继承于 Array.prototype
// (Array.prototype 中包含 indexOf, forEach 等方法)
// 原型链如下：
// a ---> Array.prototype ---> Object.prototype ---> null

function f() {
  return 2;
}

// 函数都继承于 Function.prototype
// (Function.prototype 中包含 call, bind 等方法)
// 原型链如下：
// f ---> Function.prototype ---> Object.prototype ---> null
```

#### 使用构造器创建的对象

在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。

```js
function Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype = {
  addVertex: function (v) {
    this.vertices.push(v);
  },
};

var g = new Graph();
// g 是生成的对象，他的自身属性有 'vertices' 和 'edges'。
// 在 g 被实例化时，g.[[Prototype]] 指向了 Graph.prototype。
```

#### 使用 Object.create 创建的对象

ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：

```js
var a = { a: 1 };
// a ---> Object.prototype ---> null

var b = Object.create(a);
// b ---> a ---> Object.prototype ---> null
console.log(b.a); // 1 (继承而来)

var c = Object.create(b);
// c ---> b ---> a ---> Object.prototype ---> null

var d = Object.create(null);
// d ---> null
console.log(d.hasOwnProperty); // undefined，因为 d 没有继承 Object.prototype
```

### Number、Boolean 包装类型的原型链是怎样的？

`包装类型是构造函数 -> 构造函数的原型是函数原型 -> 对象的原型-> null`

### 简单数据类型，为什么可以调用方法

<a href="https://www.cnblogs.com/venoral/p/5243189.html" target="_blank" >见</a>

```js
var s1 = 'some text';
var s2 = s1.substring(2); //'me text'
```

基本类型不是对象，因而从逻辑上讲他们不该有方法，其实为了让我们实现这种操作，后台已经完成了一系列的处理。

第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台会完成如下处理：

1. **创建** `String/Boolean/Number` 类的一个实例。`var s1=new String('some text');`
2. **调用**在实例上调用指定的方法。`var s2=s1.substring(2);//'me text'`
3. **销毁**这个实例`。s1=null`

**引用类型与基本包装类型的主要区别就是对象的生存期：**

- _使用 new 操作符创建的引用类型的实例_ ，在执行完离开当前作用域之前都一直保存在内存中。
- _自动创建的基本包装类型的对象_ ，只存在于代码执行的一瞬间，然后被立即销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。

### instanceof

instanceof 运算符

1. ~~判断一个对象是否是另一个对象的实例~~
2. 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上

### 实例与构造函数之间的关系

实例.`__proto__` === 该实例的构造函数.`prototype`

### ES6 语法中的 class、extends 与 super 的原理

<a href="https://www.cnblogs.com/rencoo/p/11879150.html" target="_blank" >见</a>

## this

### 聊下 this 指向问题

以下皆对普通函数而言，箭头函数可不是这么玩的

### 为什要有 this

简单来说：`this,被放到作用域中， 为了简化代码`

this 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。

### this 是如何定义的

简单来说： this 就是一个执行上下文中的一个属性，可以简单的把 this 当作一个对象，只不过该对象指向哪儿是在函数调用的时候确定的

我们简单总结一下 this 的特点：

- this 是在运行时绑定的，不是在编写时绑定
- this 的绑定与函数的声明和位置没有任何关系
- 函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。

所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。

简单来说：this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。

### this 绑定规则

1. 判断函数调用时是否使用了 new，如果使用了 new 绑定，则 this 绑定的是新创建的对象。
2. 函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。
3. 函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。
4. 以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，
   4.1 在严格模式下，默认绑定的 this 是 undefined，
   4.2 非严格模式下绑定到全局对象。

_类声明和类表达式的主体都执行在严格模式下_

<a href="/posts/2022-10-21js-class" target="_blank" >前端基础-class</a>

作者：小猪课堂
链接：https://juejin.cn/post/7115390077353590792
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### this 绑定的优先级

```js
// 默认绑定 < 隐式绑定 < 显式绑定 < new 绑定
```

## new 做了哪些事情

1. 创建一个空对象；
2. 将空对象的原型，指向于构造函数的原型；
3. 将空对象作为构造函数的上下文（改变 this 指向）；
4. 对有返回值的构造函数做判断处理

```js
//定义构造函数
function Fun(age, name) {
  this.age = age;
  this.name = name;
  return 1;
}

function myNew(fn, ...args) {
  //1、先创造空对象
  //其实等于var obj = Object.create({})
  var obj = {};
  //2、obj的__proto__指向原型
  Object.setPrototypeOf(obj, fn.prototype);
  //3、改变this指向，执行构造函数内部函数
  var result = fn.apply(obj, args);
  //4、判断return
  return result instanceof Object ? result : obj;
}
```

<a href="cnblogs.com/jacky02/p/16048701.html" target="_blank" >见</a>

### Object.create()

```js
function myCreate(obj) {
  let F = function () {};
  F.prototype = obj;
  return new F();
}
```

### Object.create 与 new 的区别

```js
// new Object() 方式创建
var obj = { name: 'jack' };
var b = new Object(obj);
console.log(b.name);
console.log(b.__proto__.name); //undefined

// Object.create() 方式创建
var obj2 = { name: 'apple' };
var c = Object.create(obj2);
console.log(c.name);
console.log(c.__proto__.name); //apple
```

new 出来的 b 对象，通过原型链无法访问到 name 属性，而 Object.create 出来的 c 却可以

## 箭头函数与普通函数区别

1. **使用**简单：箭头函数使用起来简单，更适合匿名函数; `比较特殊的对象方法`，可以简写`(){}`,这个不是箭头函数
2. **声明**具名箭头函数可以用 var let const , 普通函数除这些之外还可用 function 关键字

3. **立即执行** 普通函数可以声明立即执行函数，箭头函数也可`void (()=> {console.log(1)})()`
4. **运算上** 在使用短路运算符的时候，箭头函数要用`()`括起来，否则因解析顺序导致错误
5. **拥有** 箭头函数没有自己的 this， prototype，arguments, super, new.target,
6. 基于此：箭头函数不适用于`构造函数、new、yeild` 等场合
7. 在 apply,call,bind 中第一个参数会被忽略
8. 箭头函数没有 arguments，可以使用...rest, （这里有个注意的点：普通函数 arguments，**在非严格模式下**，有`默认参数、剩余参数和结构赋值`的情况会出现： arguments 与形参不一致的情况）

## 事件循环

`背景`：js 是单线程的，同一时间 dom 的操作不允许并行

`出现的原因`：单线程，如果出现耗时的情况会一直等待，以浏览器为例： 浏览器分为 5 大线程，定时器线程和网络线程

`解决了什么问题`：在单线程中，可以跳过一些耗时的操作，先去做其他的事情，待到需要执行的时候，再执行，而这一策略被称为 事件循环

`执行过程：` `宿主环境`：以浏览器环境来说

1. 在 javascript 中，将任务放到执行栈中执行，执行完成的会出栈；未执行的会依次压入栈底，
2. 先执行同步任务（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部），直至同步任务都被执行完
3. 然后执行微任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）直至微任务队列都被执行完
4. 然后执行宏任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）
5. 会再去检测微任务队列，之后，再以相同的方式去执行宏任务队列

## 闭包

## 类 class

### 单例模式

### 通过构造函数

```js
class Singleton {
  constructor() {
    console.log('this', this);
    if (!Singleton.instance) {
      // 将 this 挂载到单例上
      Singleton.instance = this;
    }
    return Singleton.instance;
  }
}
const a = new Singleton();
const b = new Singleton();
console.log(a === b);
```

### 通过静态方法

```js
class Singleton {
  static instance = null;

  static getInstance() {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}
const a = Singleton.getInstance();
const b = Singleton.getInstance();
console.log(a === b);
```

## 编程方法论

### 什么是函数式编程

1. 函数式编程是`通过组合纯函数，避免状态共享、可变数据、副作用，来构建软件的过程`。
2. 函数式编程是`声明式的`，而不是命令式的，`应用程序状态通过纯函数流动`。
3. 与面向对象编程不同，在面向对象编程中，`应用程序状态，通常与对象中的方法，共享和协作`。
4. 与命令式或面向对象的代码相比，函数式代码往往`更简洁、更可预测、更易于测试`

<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/master-the-javascript-interview-what-is-functional-programming.md" target="_blank" >见</a>

### 特点

函数式编程有些重要的概念：

1. `纯函数`： 给定相同的输入，总是得到相同的输出，没有副作用
2. `函数组合`：将两个或两个以上的函数组合起来以产生一个新函数或进行某种计算的过程
3. `避免状态共享`：共享作用域中存在的任何变量、对象或内存空间，或者是在作用域之间传递的对象的属性。共享作用域可以包括全局作用域或闭包作用域。通常，在面向对象编程中，通过向其他对象添加属性，在作用域之间共享对象。
4. `避免可变数据`： 不可变对象是指创建后不能修改的对象。相反，可变对象是在创建后可以修改的对象， 可以通过：Object.freeze 进行冻结
5. `避免副作用`：副作用是指：除了返回值之外，任何应用程序状态的改变都是可以在被调用函数之外观察到的

<a href="https://juejin.cn/post/6844904130796847111" target="_blank" >见</a>

### 什么是面向对象编程

### 什么是面向过程编程

## typescript

### type 与 interface 的区别

<a href="https://www.51cto.com/article/705857.html" target="_blank" >见</a>
<a href="https://juejin.cn/post/6844903749501059085" target="_blank" >见</a>

### 相同点

1. 都可以描述一个对象或者函数
2. 都允许拓展（extends） interface 继承使用 `extends关键字` ， type 继承使用 `&`关键字

- `interface extends interface`
- `interface extends type`
- `type extends interface`
- `type extends type`

### 不同点

- type 可以声明`基本类型别名，联合类型，元组`等类型(interface 不可以)
- type 语句中`可以使用 typeof 获取实例的 类型进行赋值`(interface 不可以)
- interface 能够声明合并 (type 不可以)

#### 描述上：1. 都可以描述一个对象或者函数

```js
// interface
interface User {
  name: string
  age: number
}

interface SetUser {
  (name: string, age: number): void;
}

// type

type User = {
  name: string
  age: number
};

type SetUser = (name: string, age: number)=> void;

```

#### 扩展上： 2. 都允许拓展（extends

interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。

```ts
// interface extends interface
interface Name {
  name: string;
}
interface User extends Name {
  age: number;
}
```

```ts
// type extends type
type Name = {
  name: string;
};
type User = Name & { age: number };
```

```ts
// interface extends type
type Name = {
  name: string;
};
interface User extends Name {
  age: number;
}
```

```ts
// type extends interface
interface Name {
  name: string;
}
type User = Name & {
  age: number;
};
```

### 不同点

#### 1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)

```ts
// 基本类型别名
type Name = string;

// 联合类型
interface Dog {
  wong();
}
interface Cat {
  miao();
}

type Pet = Dog | Cat;

// 具体定义数组每个位置的类型
type PetList = [Dog, Pet];
```

#### 2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)

```ts
// 当你想获取一个变量的类型时，使用 typeof
let div = document.createElement('div');
type B = typeof div;
```

其他骚操作

```
type StringOrNumber = string | number;
type Text = string | { text: string };
type NameLookup = Dictionary<string, Person>;
type Callback<T> = (data: T) => void;
type Pair<T> = [T, T];
type Coordinates = Pair<number>;
type Tree<T> = T | { left: Tree<T>, right: Tree<T> };

```

#### interface 能够声明合并(type 不行)

```ts
interface User {
  name: string;
  age: number;
}

interface User {
  sex: string;
}

/*
User 接口为 {
  name: string
  age: number
  sex: string
}
*/
```

## Typescript 中 extends 的作用

### 1、接口继承

可以继承父类接口的方法和属性

```ts
interface Animal {
  name: string;
}

interface Dog extends Animal {
  sayHello: () => void;
}
// dog 具有 Animal 的 name 属性。
const dog: Dog = {
  name: 'tom',
  sayHello: function () {},
};
```

### 2、普通条件判断

`用来判断一个类型是否可以分配给另外一个类型`

A extends B，是表示 A 类型能够分配给 B 类型，而不是表示 A 类型是 B 类型的子集。
换句话来说，如果条件判断的时候 A extends B 为 true，则说明约束 A 类型的一切约束条件，B 类型都具有。

```ts
interface Animal {
  name: string;
}

interface Dog extends Animal {
  sayHello: () => void;
}

const dog: Dog = {
  name: 'tom',
  sayHello: function () {},
};

type bool = Animal extends Dog ? 'yes' : 'no'; // bool = 'no'
type bool1 = Dog extends Animal ? 'yes' : 'no'; // bool1 = 'yes'
```

### 3、泛型条件判断

对于使用 extends 关键字的条件类型，`如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。`

分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。

满足两个要点即可适用分配律：

参数是泛型类型，

代入参数的是联合类型
`在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。`

```ts
type Animal<T> = T;
type Animal1<T> = [T];
type Dog = Animal<'x' | 'y'>; // Dog = 'x' | 'y'
type Dog1 = Animal1<'x' | 'y'>; // Dog1 = ['x' | 'y']

type A = 'x' extends Dog ? 'yes' : 'no'; // A= 'yes'
type B = 'x' extends Dog1 ? 'yes' : 'no'; // B = 'no'
type C = ['x' | 'y'] extends Dog1 ? 'yes' : 'no'; // C = 'yes'
type D = 'x' | 'y' extends Dog ? 'yes' : 'no'; // D = 'yes'
```

### 4、泛型约束

在书写泛型时，往往需要对类型参数作一定对限制。

```ts
function getInfo<T, key extends keyof T>(obj: T, key: key): T[key] {
  return obj[key];
}

const obj = {
  name: 'tom',
  age: 12,
};

getInfo(obj, 'age'); // 这里第二个参数只能传age或者name，传其他的字段都会报错。
```

## React

### 聊下 key

### 为什么引入 key

**key 帮助 React 识别出被修改、添加或删除的 item**

<a href="https://react.docschina.org/docs/reconciliation.html#recursing-on-children" target="_blank" >深入解析为什么 key 是必须的</a>

### 引入 key 的背景

对子节点进行递归

默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。

在子元素列表末尾新增元素时，更新开销比较小。比如：

```jsx
<ul>
  <li>first</li>
  <li>second</li>
</ul>

<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

React 会先匹配两个 `<li>first</li>` 对应的树，然后匹配第二个元素 `<li>second</li>` 对应的树，最后插入第三个元素的 `<li>third</li>` 树。

如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：

```jsx
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

React 并不会意识到应该保留 `<li>Duke</li>` 和 `<li>Villanova</li>`，而是会重建每一个子元素。这种情况会带来性能问题。

### key 解决这个问题

为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高：

```jsx
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

```

现在 React 知道只有带着 '2014' key 的元素是新元素，带着 '2015' 以及 '2016' key 的元素仅仅移动了。

实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：

```jsx
<li key={item.id}>{item.name}</li>
```

当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。

### key 有什么要求

当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。

### 通常情况 key 不会用 index

原因：

1. 使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢。

2. 由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，

### 什么时候使用 key

1. 子元素列表时候需要用 key
2. 同级元素比如两个按钮，在使用三目运算符进行条件处理时候，也需要加 key，不加会出现，按钮事件被错误触发的现象，（这是由于 React 可中断渲染和合成事件共同作用引起的）

### key 在源码单节点、多节点中的

### diff [单节点、多节点]

### hooks 产生的原因

Hook 解决了我们五年来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题

### `在组件之间复用状态逻辑很难`

### `复杂组件变得难以理解`

在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。）

### `难以理解的 class`

(除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 React 的一大屏障。你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。如果不使用 ES2022 public class fields，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。

为了解决这些问题，

1. `Hook 使你在非 class 的情况下可以使用更多的 React 特性`。
2. 从概念上讲，`React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则`。
3. Hook 提供了问题的解决方案，`无需学习复杂的函数式或响应式编程技术`。

### useEffect 执行特点

#### 1. useEffect 做了什么？

(
通过使用这个 Hook，你可以`告诉 React 组件需要在渲染后执行某些操作`。React 会保存你传递的函数（我们将它称之为 “effect”），`并且在执行 DOM 更新之后调用它`。
)

#### 2. 为什么在组件内部调用 useEffect？

(
将 useEffect 放在组件内部,让我们可以在 effect 中直接访问 count state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。
)

#### 3. useEffect 会在每次渲染后都执行吗？

(
是的，`默认情况下，它在第一次渲染之后和每次更新之后都会执行`。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。`React 保证了每次运行 effect 的同时，DOM 都已经更新完毕`。
)

#### 4. 传递给 useEffect 的函数在每次渲染中都会有所不同

(
经验丰富的 JavaScript 开发人员可能会注意到，`传递给 useEffect 的函数在每次渲染中都会有所不同`，这是刻意为之的。`事实上这正是我们可以在 effect 中获取最新的 count 的值，而不用担心其过期的原因`。每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。
)

#### 5. effect 异步执行

不需要同步地执行, 如果需要同步用 `useLayoutEffect`

#### 6. 为什么要在 effect 中返回一个函数？

(
这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。
)

#### 7. React 何时清除 effect？

(

1. `React 会在组件卸载的时候执行清除操作`。
2. 正如之前学到的，effect 在每次渲染的时候都会执行。`这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。`
   )

### useEffect 使用特点上？

1. 提示: 使用多个 Effect 实现关注点分离
2. 解释：为什么每次更新的时候都要运行 Effect(`此默认行为保证了一致性，避免了在 class 组件中因为没有处理更新逻辑而导致常见的 bug`。)
3. 提示: 通过跳过 Effect 进行性能优化（`使用第二参数，未来版本，可能会在构建时自动添加第二个参数。`）

### useEffect 实现原理

### Hook 使用规则

Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：

1. `只能在 React 的函数组件中调用 Hook`。不要在其他 JavaScript 函数中调用。
2. 只能`在函数最外层调用 Hook`。`不要在循环`、`条件判断`或者`子函数中调用`。
3. 在自定义的 Hook 中

### 生命周期

1. 挂载：constructor()、static getDerivedStateFromProps()、render()、componentDidMount()
2. 更新：static getDerivedStateFromProps()、shouldComponentUpdate()、render()、getSnapshotBeforeUpdate()、componentDidUpdate()
3. 错误处理：static getDerivedStateFromError()、componentDidCatch()
4. 卸载：componentWillUnmount()

**react 生命周期函数：**

1. constructor()：组件构造函数，在组件挂载之前调用；`仅用于初始化内部 state 以及为事件处理函数绑定实例`；

2. `static getDerivedStateFromProps()`：会在调用 render 方法之前调用，并且`在初始挂载及后续更新时都会被调用`，此方法适用于 state 的值在任何时候都取决于 props；

3. render()：是 class 组件中唯一必须实现的方法；

4. componentDidMount：会在组件挂载后（插入 DOM 树中）立即调用；

5. shouldComponentUpdate()：根据该函数的返回值，来确定组件是否重新渲染；

6. getSnapshotBeforeUpdate()：在最近一次渲染输出（提交到 DOM 节点）之前调用；`此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()`；

7. componentDidUpdate()：会在更新后会被立即调用，首次渲染不会执行此方法；

8. componentWillUnmount()：会在组件卸载及销毁之前直接调用；

9. `static getDerivedStateFromError()`：此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state；它会在渲染阶段调用，因此不允许出现副作用

10. `componentDidCatch()`：此生命周期在后代组件抛出错误后被调用，会在“提交”阶段被调用，因此允许执行副作用。

### 父子组件生命周期函数执行顺序：

父子组件生命周期函数执行顺序：

**类组件**

**进入页面：**

```jsx
parent-constructor ->
parent-getDerivedStateFromProps ->
parent-render ->

child-constructor ->
child-getDerivedStateFromProps ->
child-render ->
child-componentDidMount ->

parent-componentDidMount
// （子组件先挂载，父组件后挂载）
```

**更新页面：**

```jsx
parent-getDerivedStateFromProps ->
parent-shouldComponentUpdate ->
parent-render ->

child-getDerivedStateFromProps ->
child-shouldComponentUpdate ->
child-render ->
child-componentDidUpdate ->

parent-componentDidUpdate
// （子组件先更新，父组件后更新）
```

**销毁页面：**

```jsx
parent-componentWillUnmount ->
child-componentWillUnmount

//（父组件先 willUnmount，子组件后 willlUnmount）
```

<a href="https://www.cnblogs.com/foreveronlymiss/p/15387022.html" target="_blank" >见</a>

**函数组件**

子组件先于父组件

<a href="https://blog.csdn.net/qq_35770417/article/details/120706178" target="_blank" >见</a>

### 严格模式 StrictMode

1. 环境： 严格模式检查`仅在开发模式下运行`；它们不会影响生产构建
2. 范围：`它为其后代元素触发额外的检查和警告`
3. 作用：`突出显示应用程序中潜在问题的工具`，不会渲染任何可见的 UI

作用具体表现：

1. 识别`不安全的生命周期`（使用了第三方库，很难确保它们不使用这些生命周期方法）
2. 使用过时`字符串 ref API`、 `context API`
3. 使用`废弃的 findDOMNode 方法`的警告
4. `检测意外的副作用`
5. 确保可复用状态（在未来，我们希望增加一个功能，允许 React 在保留 state 的同时对 UI 进行增删）

### 协调

当组件的 props 或 state 发生变化时，React 通过将最新返回的元素与原先渲染的元素进行比较，来决定是否有必要进行一次实际的 DOM 更新。当它们不相等时，React 才会更新 DOM。这个过程被称为“协调”。

### 合成事件的捕获和冒泡如何实现

数组正反序遍历

### 父子组件合成事件的捕获和冒泡执行顺序

V17 之前，`合成事件和原生事件的执行顺序与冒泡/捕获模式无关`,

`原生事件恒早于合成事件`

V17 后，`合成事件和原生事件的执行顺序与冒泡/捕获模式相关`，

1.  `捕获模式，合成事件早于原生事件`。
2.  `冒泡模式，原生事件早于合成事件`，
3.  React 17 将事件委托放在了 root 上而不是以前的 document 上

```js
// V17.0.2 document 原生事件 > 合成事件（父 -> 子） > 原生事件（父 -> 子）
// 原生事件：document DOM 事件监听！
// React 事件：父元素事件监听！
// React 事件：子元素事件监听！
// 原生事件：父元素 DOM 事件监听！
// 原生事件：子元素 DOM 事件监听！
```

```js
// V16.14.0 document 原生事件 > 原生事件（父 -> 子）> 合成事件（父 -> 子）
// 原生事件：document DOM 事件监听！
// 原生事件：父元素 DOM 事件监听！
// 原生事件：子元素 DOM 事件监听！
// React 事件：父元素事件监听！
// React 事件：子元素事件监听！
```

作者：活抓一只小机灵
链接：https://juejin.cn/post/7005129812981317668
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 合成事件

### 是什么？

是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口。

### 要使用浏览器的底层事件？

需要使用 nativeEvent 属性来获取

### 变化？

从 v17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中。

### 在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？

如需注册捕获阶段的事件处理函数，则应为事件名添加 Capture。例如，处理捕获阶段的点击事件请使用 onClickCapture，而不是 onClick。

### 事件委托的变更

1. React v17 中，React 不会再将事件处理添加到 document 上，而是将事件处理添加到渲染 React 树的根 DOM 容器中
2. 原因：经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，其中大多与将 React 与非 React 代码集成有关。

### 全新的 JSX 转换

此时源代码无需引入 React 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）

此变化与所有现有 JSX 代码兼容，所以你无需修改组件。如果你对此感兴趣，你可以查看 RFC 了解全新转换工作的具体细节。

特点：

- 新的 JSX 转换不依赖 React 环境

优点：

- 不需要引入 React 使用全新的转换，你可以单独使用 JSX 而无需引入 React。
- 改善 bundle 根据你的配置，JSX 的编译输出可能会略微改善 bundle 的大小。
- 以备未来之需 它将减少你需要学习 React 概念的数量，以备未来之需。

### 副作用清理时间

- React 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。
- React 16 只对组件内的 effect 保证这种顺序。

### React17 重大更改

1. `更改事件委托`
2. `对标浏览器，对事件系统进行小改`
3. `去除事件池` 不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水 （因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 e.persist() 才能正确的使用该事件，或者正确读取需要的属性。）
4. `副作用清理时间` （- React 17 将`在运行任何新副作用之前执行所有副作用的清理函数`（针对所有组件）。，- React 16 只对组件内的 effect 保证这种顺序。）
5. `返回一致的 undefined 错误`，（算是改 bug 了，forwardRef 和 memo 组件的行为会与常规函数组件和 class 组件保持一致。在返回 undefined 时会报错）
6. `原生组件栈` （生产环境提示更友好。
   1. 在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。_React 实现这一点的方式有点非常规_ 。目前，浏览器无法提供获取函数调用栈框架（源文件和位置）的方法。
   2. 因此，_当 React 捕获到错误时，将通过组件上述组件内部抛出的临时错误（并捕获）来重建其组件调用栈信息_ ）
7. `移除私有导出`（与 react 关联不是很大的部分被移出）

### react18 新特性

1. 修 bug

   1. 由于并发模式可能带来破坏，所以 react18 的并发模式可选
   2. `Suspense fallback={undefined}` 表现与`null`相同

2. 增加开发体验

   1. 自动批处理: 之前需要使用 `ReactDOM.unstable_batchedUpdates`, 现在： 超时、promise、本机事件处理程序、任何其他事件被批处理
   2. 内置 `React.lazy + Suspense`
   3. `useId`: 生成唯一 ID
   4. `useTransition、useDeferredValue`: 将紧急更新与非紧急更新分开
   5. 2 个新的`渲染api`: `createRoot` 和 `hydrateRoot` ：应用的根节点也向我们暴露了出来，渲染整个应用的时候只需要调用 root 的 render 方法

3. 为其他框架库提供扩展

   1. `useInsertionEffect`: 为 CSS-in-JS 库添加 <a href="https://segmentfault.com/a/1190000040966821#:~:text=/%3E%0A%20%20%20%20%3C/%3E%0A%20%20)%3B%0A)%3B-,useInsertionEffect,-%E7%94%A8%E4%BA%8E%E6%8F%92%E5%85%A5%E5%85%A8%E5%B1%80" target="_blank" >见</a>
   2. `useSyncExternalStore`: 帮助外部存储库与 React 集成。 <a href="https://juejin.cn/post/7056588815170813965" target="_blank" >见</a>

4. 为以后做准备

   1. 严格模式模拟卸载和重新挂载

### 错误处理

#### componentDidCatch

React 的开发和生产构建版本在 componentDidCatch() 的方式上有轻微差别。

1. 在开发模式下，错误会冒泡至 window，这意味着任何 window.onerror 或 window.addEventListener('error', callback) 会中断这些已经被 componentDidCatch() 捕获的错误。
2. 在生产模式下，错误不会冒泡

#### static getDerivedStateFromError()

1. `getDerivedStateFromError() `会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch()。

```js
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染可以显降级 UI
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      // 你可以渲染任何自定义的降级  UI
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}
```

## git

### git rebase 与 git merge

<a href="https://blog.csdn.net/small_white_123/article/details/121563248" target="_blank" >见</a>

<img src="http://t-blog-images.aijs.top/img/202301281645578.webp" />

1. merge(合并): 会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）
2. rebase（变基）: 变基使得提交历史更加整洁, 尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉，
3. 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。

### 变基原理：

1. 是首先找到这两个分支的最近共同祖先 C2
2. 然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3
3. 最后以此将之前另存为临时文件的修改依序应用

### 什么时候用哪个？

这本身存在分歧，主要看团队需要，

1. 如果团队需要历史记录保留，便于追踪，可以使用 merge ,
2. 如果不希望保留过多的过程，只关注结果那么可以用 rebase.无论用哪个，为了避免 rebase 的坑， 需要遵循以下原则：

### 原则

总的原则是，`只对尚未推送或分享给别人的本地修改执行变基操作清理历史`， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。

```
$ git rebase --onto master server client
```

你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：

<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#:~:text=Figure%2039.%20%E4%BB%8E%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E9%87%8C%E5%86%8D%E5%88%86%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" >见</a>

```shell

git rebase -i HEAD~4
# s 命令压缩
```

<img src="http://t-blog-images.aijs.top/img/202209171547417.png" />

<img src="http://t-blog-images.aijs.top/img/202209171551269.png" />

<a href="https://www.cnblogs.com/lookphp/p/5799533.html" target="_blank" >见</a>

<a href="https://backlog.com/git-tutorial/cn/stepup/stepup7_7.html" target="_blank" >见</a>

### 🤔

<img src="http://t-blog-images.aijs.top/img/202209181100864.png" />

<img src="http://t-blog-images.aijs.top/img/202209181059249.png" />

```
♠ /Users/chenhailong/Desktop/841660202.github.io $ git rebase -i HEAD~3
The previous cherry-pick is now empty, possibly due to conflict resolution.
If you wish to commit it anyway, use:

    git commit --allow-empty

Otherwise, please use 'git reset'
interactive rebase in progress; onto e1a52d3
Last commands done (2 commands done):
   pick 78c1fd9 应对github bug s 压缩
   pick 8935665 应对github bug
Next commands to do (4 remaining commands):
   pick 421821a update
   pick 4eff6a3 update
You are currently rebasing branch 'main' on 'e1a52d3'.

nothing to commit, working tree clean
Could not apply 8935665... 应对github bug
♠ /Users/chenhailong/Desktop/841660202.github.io $
♠ /Users/chenhailong/Desktop/841660202.github.io $
♠ /Users/chenhailong/Desktop/841660202.github.io $
♠ /Users/chenhailong/Desktop/841660202.github.io $
♠ /Users/chenhailong/Desktop/841660202.github.io $ git rebase -i HEAD~2

It seems that there is already a rebase-merge directory, and
I wonder if you are in the middle of another rebase.  If that is the
case, please try
        git rebase (--continue | --abort | --skip)
If that is not the case, please
        rm -fr "/Users/chenhailong/Desktop/841660202.github.io/.git/rebase-merge"
and run me again.  I am stopping in case you still have something
valuable there.
$ git rebase --abort
```

## 掘金小猪课堂

### for...in 和 for...of 的区别

1. for...in 可以遍历对象和数组，for...of 不能遍历对象
2. for...in **循环不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键**
3. for...in 遍历的索引为字符串类型
4. for..of 适用遍历数组/字符串/map/set 等拥有迭代器对象的集合，但是不能遍历对象
5. for...of 与 forEach()不同的是，它可以正确响应 break、continue 和 return 语句
6. 具有迭代器对象才可以使用 for...of

作者：小猪课堂
链接：https://juejin.cn/post/7002484014414037000
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### JavaScript 中可迭代对象

1. String、Array、Set、Map
2. NodeList、Arguments

### <a href="https://juejin.cn/post/7075305529903415304" target="_blank" >几种获取 URL 参数</a>

1. 通过正则匹配的方式
2. 利用 split 方法分割法
3. 使用 URLSearchParams 方法
4. 利用 a 标签内置方法

```js
// - 通过正则匹配的方式
<script>
  // 利用正则表达式
  let url = "http://www.baidu.com?name=elephant&age=25&sex=male&num=100"
  // // 返回参数对象
  function queryURLParams(url) {
    let pattern = /(\w+)=(\w+)/ig; //定义正则表达式
    let parames = {}; // 定义参数对象
    url.replace(pattern, ($, $1, $2) => {
      parames[$1] = $2;
    });
    return parames;
  }
  console.log(queryURLParams(url))
</script>

// - 使用 URLSearchParams 方法
<script>
  let URL = "http://www.baidu.com?name=elephant&age=25&sex=male&num=100"
  function queryURLParams(URL) {
    let url = URL.split("?")[1];
    const urlSearchParams = new URLSearchParams(url);
    const params = Object.fromEntries(urlSearchParams.entries());
    return params
  }
  console.log(queryURLParams(URL))
</script>

// 作者：小猪课堂
// 链接：https://juejin.cn/post/7075305529903415304
// 来源：稀土掘金
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### clientHeight、offsetHeight、scrollHeight 的区别

三个属性虽然都很类似，但是每一个又有一些不一样的地方，总结起来就下面三点：

```js
/*内容*/ clientheight = 内容高度 + padding;
/*占据空间*/ offsetHeight = 内容高度 + padding + border;
/*滚动*/ scrollHeight = 内容实际尺寸 + padding;

// 作者：小猪课堂
// 链接：https://juejin.cn/post/7085317886046126087
// 来源：稀土掘金
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### childNodes 和 children 有什么区别？

**Node -> childNodes**

在 DOM 树中，所有的节点都是 Node，包括 Element，也就是说 Node 包含了 `HTML 元素标签`、`text`、`以及注释`等等内容，它是所有 DOM 的基类。

**Element -> HTMLCollection**

在 DOM 树中，Element 只包含 HTML 元素标签。

**关系**

1. childNodes 属于 NodeList 集合，它会返回所有的子节点，包括文本、标签、注释等等。
2. children 数据 HTMLCollection 集合，它会返回所有 HTML 元素节点。
3. childNodes 包含 children。

### Ajax、Fetch、Axios 三者的区别

**Ajax**

_全称：_ Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”。
_特点_ 局部刷新页面，无需重载整个页面。
_简单来说_ Ajax 是一种思想，XMLHttpRequest 只是实现 Ajax 的一种方式。

```js
  <script>
    function ajax(url) {
      // 实例
      const xhr = new XMLHttpRequest();
      // 方法
      xhr.open("get", url, false);
      // 监听
      xhr.onreadystatechange = function () {
        // 异步回调函数
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            console.info("响应结果", xhr.response)
          }
        }
      }
      // 发送
      xhr.send(null);
    }

    ajax('https://smallpig.site/api/category/getCategory')
  </script>
```

**Fetch**

*注意：*不应该和 Ajax 做比较, 应该和 `XMLHttpRequest`做比较， Ajax 一个是思想，Fetch 一个是真实存在的 API

_特点_

1. Fetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象
2. 内置的 API，使用上更简单
3. 使用 promise, 不使用回调
4. 数据流对象处理数据`常用res.json()转化成json数据`

**Axios**

*Axios*是一个基于 promise 和 XHR 封装的网络请求库

_特点：_

1. 从浏览器中创建 XMLHttpRequests，从 node.js 创建 http 请求
2. 支持 Promise API
3. 能够拦截请求和响应，转换请求数据和响应数据
4. 具备 `取消请求，自动转换 JSON 数据，客户端支持防御 XSRF` 的特点

<img src="http://t-blog-images.aijs.top/img/202210171747226.webp" />

### 判断两个对象是否相等

### 将类数组转为数组

_类数组特点：_

1. 类数组是一个对象， 带有 length 属性
2. 没有数组方法，即不可调用数组的原型方法

_类数组：_

1. arguments
2. HTMLCollection
3. NodeList

_实现方案_

1. Array.from ES6 提供的方法，只能实现浅拷贝
2. 扩展运算符 不能使用在非迭代对象上
3. 数组 slice 方法 在不改变原数组的情况下返回数组中的某些元素并形成新的数组。

### 判断数据类型

1. `typeof` 能判断基本数据类型，不能判断引用数据类型
1. `instanceof` 可以判断引用数据类型, 不能判断基本数据类型

虽然上面两个结合可以处理，但是过于复杂

每个对象都有一个  toString()  方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()  方法被每个  Object  对象继承。

`如果此方法在自定义对象中未被覆盖，toString()  返回  "[object type]"，其中  type  是对象的类型`

作者：小猪课堂
链接：https://juejin.cn/post/7089322067677413412
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```js
<script>
  function getType(data) {
    let originType = Object.prototype.toString.call(data); // 获取内部属性值
    let index = originType.indexOf(' '); // 以空格分割
    let type = originType.slice(index + 1, -1); // 截取 [object Number]
    return type.toLowerCase();
  }
  console.info(getType("小猪课堂")); // string
  console.info(getType(123)); // number
  console.info(getType(true)); // boolean
  console.info(getType(null)); // null
  console.info(getType(undefined)); // undefined
  console.info(getType({ name: "小猪课堂" })); // object
  console.info(getType([1,3,2])); // array
  console.info(getType(Promise.resolve())); // promise
  console.info(getType(new Set())); // set
  console.info(getType(new WeakMap())); // weakmap
  console.info(getType(new Date())); // date
  console.info(getType(() => {})); // function
  console.info(getType(new Map)); // map
  console.info(getType(BigInt(100))); // bigint
  console.info(getType(new RegExp(''))); // regexp
  console.info(getType((Symbol()))); // symbol
</script>

```

### session、cookie、token 的区别？

1.为什么会有它们？

**无状态**
我们都知道 HTTP 协议是无状态的，所谓的无状态就是客户端每次想要与服务端通信，都必须重新与服务端链接，意味着请求一次客户端和服务端就连接一次，下一次请求与上一次请求是没有关系的。

**区分用户**
这种无状态的方式就会存在一个问题：如何判断两次请求的是同一个人？
就好比用户在页面 A 发起请求获取个人信息，然后在另一个页面同样发起请求获取个人信息，我们如何确定这俩个请求是同一个人发的呢？

为了解决这种问题，我们就迫切需要一种方式知道发起请求的客户端是谁？此时，cookie、token、session 就出现了，它们就可以解决客户端标识的问题，在扩大一点就是解决权限问题。

它们就好比让每个客户端或者说登录用户有了自己的身份证，我们可以通过这个身份证确定发请求的是谁！

作者：小猪课堂
链接：https://juejin.cn/post/7090503270447185951
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

cookie 的缺点：

1. 增加请求体积，浪费性能，因为每次请求都会携带 cookie。
2. 增加服务端资源消耗，因为每个客户端连接进来都需要生成 session，会占用服务端资源的。
3. 容易遭受 CSRF 攻击，即跨站域请求伪造。

### new 做了哪些操作？手写一个 new 方法！

```js
<script>
  // 定义构造函数
  function Person(name, age) {
    this.name = name;
    this.age = age;


    return this.name + ':' + this.age
  }
  // 定义原型方法
  Person.prototype.say = function () {
    console.log("你好：", this.name)
  }


  // 手动实现new方法
  function myNew(constructor) {
    if (typeof constructor !== "function") {
      throw "myNew方法的第一个参数必须是一个方法";
    }


    // 基于constructor的原型创建一个全新的对象
    let newObj = Object.create(constructor.prototype);


    // 获取传入的参数
    let args = Array.from(arguments).slice(1);


    // 执行constructor函数，获取结果，并将属性添加到新对象newObj上
    let result = constructor.apply(newObj, args); // 将this指向newObj


    // 判断result类型，如果是object或者function类型，则直接返回结果
    let originType = Object.prototype.toString.call(result); // 获取内部属性值
    let isObject = originType === '[object Object]';
    let isFunction = originType === '[object Function]';
    if (isObject || isFunction) {
      return result;
    } else {
      // 返回新对象
      return newObj;
    }
  }


  let obj = myNew(Person, '小猪课堂', 26);
  console.log(obj);
  obj.say();
</script>
```

## 跨标签页的通讯方式有哪些

### 为什么需要跨标签页通信

一个标签页的数据，要同步给另一个标签页

### 列举

#### 同源

1. `广播模式：`Broadcast Channel / LocalStorage + StorageEvent / Service Worker /
2. `存储模式：`Shared Worker / IndexedDB / cookie
3. `传递模式：`window.open + window.opener `有局限性：只有从一个 tab 打开新 tab,新 tab 才可以拿到之前 tab 的引用`
4. `基于服务端：`Websocket / Comet / SSE 等
5. `visibilitychange` 监听 tab 展示

#### 非同源：

1. `可以使用一个用户不可见的 iframe 作为“桥”。`
2. `由于 iframe 与父页面间， 通过指定 origin 来忽略同源限制`，`因此可以在每个页面中嵌入一个 iframe （例如：http://sample.com/bridge.html），
3. 而这些 iframe 由于使用的是一个 url，因此属于同源页面`，其通信方式可以复用上面第一部分提到的各种方式

作者：AlienZHOU
链接：https://juejin.cn/post/6844903811232825357
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 参考资料

1. <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Broadcast_Channel_API" target="_blank" >Broadcast_Channel_API</a>
2. <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Page_Visibility_API" target="_blank" >Page_Visibility_API</a>
3. <a href="https://juejin.cn/post/6844903811232825357" target="_blank" >面试官：前端跨页面通信，你知道哪些方法？</a>

### 演示

```html
<iframe src="https://alienzhou.github.io/cross-tab-communication/" style={{width: '100%',; height: 800}}></iframe>
```

### 源码

<a href="https://github.com/alienzhou/alienzhou.github.io/blob/master/cross-tab-communication/index.html" target="_blank" >见</a>

### 非同源

<a href="https://juejin.cn/post/6869686782942773255" target="_blank" >见</a>

实现原理：
http://localhost:3000/bbb.html（简称 bbb 页面）嵌入 iframe 页面 http://localhost:3001/a.html（简称 iframe 页面）
iframe 能够接受父级页面 bbb.html 发送过来的数据
与此同时 iframe 与实际需要接受数据的 http://localhost:3001/b.html(简称 b 页面)同源，所以可以通过同源通信的 Broadcast Channel 方式将 iframe 接受到的数据发送给 b 页面实现 bbb 页面与 b 页面之间的数据发送

作者：Tsuki\_
链接：https://juejin.cn/post/6869686782942773255
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### demo 代码

```js
// 父传子

iframe.contentWindow.postMessage('父页面传送的数据', '*');

// 父接子

window.addEventListener('message', function (data) {
  console.log(data);
});

// 子接父
window.addEventListener('message', function (obj) {
  console.log('子页面');
  console.log(obj);
  let parentWindow = obj.source;
  parentWindow.postMessage('子页面传送的数据', '*');
});
// 子传父
function sendMesg() {
  window.parent.window.postMessage('子页面传送的数据', '*');
}
```

<a href="https://blog.csdn.net/wangliuqi123/article/details/109577991" target="_blank" >见</a>

## transition 和 animation 的属性分别有哪些

<a href="https://blog.csdn.net/gtLBTNq9mr3/article/details/123587378" target="_blank" >见</a>

| 对比点       | transition                                                                                 | animation                                                                                 |
| :----------- | :----------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------- |
| `侧重点`     | `单一动画属性`的过度效果,其`过程是简单`，<br/>由开始到结束的过程，中间不存在可能的动画转折 | 强调的是`多种动画属性的结合`，<br/>按时间轴线出现周折性动画变换的动画过程，其过程是复杂的 |
| `状态`       | 开始状态 和 结束状态                                                                       | 多个状态，有帧的概念                                                                      |
| `功能更强大` |                                                                                            | “播放次数”、“播放方向”、“播放状态”                                                        |
| `触发`       | 选择器/js 来触发                                                                           | 自动触发                                                                                  |
| `使用规则`   |                                                                                            | 需 @keyframes /animation-name                                                             |
| `动效控制`   | “持续时间”、“延迟时间” 、“时间缓动函数”                                                    | 同前者                                                                                    |

<a href="https://www.zhangxinxu.com/wordpress/2018/06/css3-animation-steps-step-start-end/" target="_blank" >CSS3 animation 属性中的 steps 功能符深入介绍</a>

1. `状态`：CSS 的 transition 只有两个状态：开始状态 和 结束状态；但 animation 可能是多个状态，有帧的概念
2. `触发`：CSS 的 transition 需要借助别的方式来触发，比如 CSS 的状态选择器（如:hover）或 借助 JavaScript 来触发；animation 可以自动触发
3. `动效控制`：CSS transition 和 animation 虽然实现动效方式不同，但他们之间有些概念是相同的。比如他们都有“持续时间”、“延迟时间” 和“时间缓动函数”等概念，这些都是用来控制动效的效果。
4. CSS 的 animation 是离不开 @keyframes 的，换句话说，我们需要先使用 @keyframes 来注册一个动画效果，即帧来描述动画效果。当然，只注册也不见得有效果，还是需要使用 animation-name 属性引用 @keyframes 注册好的动画效果。
5. animation 控制动效上要比 transition 强，因为它具备一些控制动效的属性，比如“播放次数”、“播放方向”、“播放状态”等。

6. CSS transition 强调的是单一动画属性的过度效果,其过程是简单的，由开始到结束的过程，中间不存在可能的动画转折，只有 0 到 1，比喻：渐隐，渐显;
7. CSS animation 强调的是多种动画属性的结合，按时间轴线出现周折性动画变换的动画过程，其过程是复杂的，由开始——>结束的过程中，存在可能的动画转折，其过程可能是开始—0—1—2—3>结束的过程。

综合来说：CSS animation 可以包括 CSS transition 的动画形式。感觉两者之间,transition 像是 animation 的子集。

## CSS3 font

1. 必须要先有字体文件
2. `@font-face`声明字体
   ```html
   <style>
     @font-face {
       font-family: myFirstFont;
       src: url('你自己的字体文件路径.ttf');
     }
   </style>
   ```
3. css 选择器中使用 `font-family`

## 柯里化

### 是什么

柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的技术。

_函数柯里化，是可以用来慢慢凑齐参数，延迟函数的执行。（先分期交钱，后交货！）_

### 实现原理

函数有记忆功能（多次接受参数，记忆历史参数信息），累积接受参数个数函数小于定义参数个数时返回一个函数，继续接受参数，`典型的闭包 + 递归`

### 为什么会出现

### 柯里化

```js
const curry = (fn, ...rest) => {
  return (...args) => {
    //判断参数总数是否和fn参数个数相等
    if ([...rest, ...args].length === fn.length) {
      return fn(...rest, ...args); //拓展参数，调用fn
    } else {
      return curry(fn, [...rest, ...args]); //迭代，传入现有的所有参数
    }
  };
};

// const curry = (fn, ...args1) => (...args2) => ((arg) => (arg.length === fn.length ? fn(...arg) : curry(fn, ...arg)))([
//       ...args1,
//       ...args2,
//     ]);

// 调用
const foo = (a, b, c) => a * b * c;
curry(foo)(2, 3, 4); // -> 24
curry(foo, 2)(3, 4); // -> 24
curry(foo, 2, 3)(4); // -> 24
curry(foo, 2, 3, 4)(); // -> 24
```

<a href="https://www.jianshu.com/p/c87242cd2f6c" target="_blank" >见</a>

## 异步编程 promise 与 async 的区别

### async 特点

#### 为什么

1. async 解决了什么问题 promise 链式调用的烦恼
2. async 和 await 关键字,让我们可以用一种更简洁的方式， 写出基于 Promise 的异步行为，而无需刻意地链式调用 promise

#### 构成

- async 函数是 AsyncFunction 构造函数的实例 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function#:~:text=async%20%E5%87%BD%E6%95%B0%E6%98%AF%20AsyncFunction%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BE%8B" target="_blank" >见</a>

#### 是什么

1. async 函数可能包含 0 个或者多个 await 表达式。
2. await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。
3. promise 的解决值会被当作该 await 表达式的返回值

#### 注意点

1. 从第一行代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的。
2. 一个不含 await 表达式的 async 函数是会同步运行的。
3. 如果函数体内有一个 await 表达式，async 函数就`一定`会异步执行。

#### 返回值

- async 返回值`一定`为 promise, 如果返回值不是 promise，将会被隐式包装在一个 promise 中

```js
async function foo() {
  return 1;
}
// 等价于
function foo() {
  return Promise.resolve(1);
}
```

```js
console.log(1);
async function foo() {
  console.log(2);
  await 1;
  console.log(3);
}
foo();
console.log(4);

// 结果：1243
```

#### 两个 await, 执行说明

```js
async function foo() {
  const result1 = await new Promise((resolve) => setTimeout(() => resolve('1')));
  const result2 = await new Promise((resolve) => setTimeout(() => resolve('2')));
}
foo();
```

1. foo 函数的第一行将会同步执行，await 将会等待 promise 的结束。然后暂停通过 foo 的进程，并将控制权交还给调用 foo 的函数。(控制权转出)
2. 一段时间后，当第一个 promise 完结的时候，控制权将重新回到 foo 函数内。示例中将会将 1（promise 状态为 fulfilled）作为结果返回给 await 表达式的左边即 result1。 (控制权转入)
3. 接下来函数会继续进行，到达第二个 await 区域，此时 foo 函数的进程将再次被暂停。(控制权转出)
4. 一段时间后，同样当第二个 promise 完结的时候，result2 将被赋值为 2，之后函数将会正常同步执行，将默认返回 undefined (控制权转入)

_注意： promise 链不是一次就构建好的，相反，promise 链是分阶段构造的，因此在处理异步函数时必须注意对错误函数的处理。_

#### async/await 和 Promise/then 对比以及错误处理

1. 大多数 async 函数也可以使用 Promises 编写。但是，`在错误处理方面，async 函数更容易捕获异常错误`
2. 如果任一 `awaited 调用失败`，它将`自动捕获异常`，async 函数`执行中断`，并通过`隐式返回 Promise `将错误传递给调用者
3. `async 函数仍有可能然可能错误地忽略错误`. 在 async 中， 没有等待 await 返回，则不会传播任何错误

### 总结

1. `简单`：promise 链式调用繁杂，async/await 相对来说，更简单
2. `并发`：promise api 能够实现并发， async/await 只会顺序执行
3. `返回`：async/await 的返回值，一定是一个 promise，会进行隐式的包装（如果在发生错误时候进行，捕获处理然后返回一个值，之后真正返回并不是这个值，而是被 promise 包装了）
4. `错误`：async/await 在处理错误方面更容易（任意一个 await 出错，会自动捕获异常，执行中断，隐式返回 promise 错误，这几个环环相扣）,如果没有等待返回的情况下，async 可能错误的忽略错误，不进行传播错误
5. `错误捕获`：因 async/await 一定返回的是 promise,所以 async/await 既可以用`try catch`， 也可以用`.catch` (`try catch`是 js 语法，`.catch`是`promise.catch`语法)

## 包装对象/原型与原型链

### 包装对象的含义

（Number/String）经过封装，能够处理（number/string）的对象

### 继承关系

<div style={{
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  alignItems: "flex-start"
}}>
<img src="http://t-blog-images.aijs.top/img/202210261711923.webp" style={{width: 550,maxWidth:'100%'}} />
<div style={{width:10}}></div>
<img src="http://t-blog-images.aijs.top/img/202210261734112.webp" style={{width: 360,maxWidth:'100%'}}/>
</div>

细品 原型与原型链关系图：

竖着看分为三栏：左侧为实例对象，中间为构造函数，右侧为原型对象

| 序号 | 实例                  | 构造函数 <span style={{color: 'red'}}>created by Function</span> | 原型对象                    |
| :--- | :-------------------- | :--------------------------------------------------------------- | :-------------------------- |
| 1    | new Foo/Number/String | function Foo/Number/String()                                     | Foo/Number/String.prototype |
| 2    | new Object            | function Object()                                                | Object.prototype            |
| 3    |                       | function Function()                                              | Function.prototype          |

**注意：序号 1**
从 MDN Number 包装对象的目录接口也可以看出：Number 的原型链： `Function.prototype -> Object.prototype -> null`

```js
// .__proto__ 表示：隐式原型
// .prototype 表示：显示原型
实例.__proto__ == 实例的原型对象
构造函数的.__proto__ == Function 的原型对象
原型对象的.constructor == 对应的构造函数
构造函数的.prototype == 对应的原型对象
非(Object 和 null)的.__proto__ == Object.prototype
Object.__proto__ == null

// 有意思的是 Function
Function.__proto__ == Function.prototype

```

## Object.freeze() vs Object.seal() vs Object.preventExtensions()

### Object.freeze()

1. 不增加新属性、不删除已有属性、不赋值
2. 子属性对象可编辑

### Object.seal()

1. 不增加新属性、不删除已有属性
2. 可赋值

### Object.preventExtensions()

1. 不增加新属性
2. 可改已有属性

### 区分

| 特性           | 默认 | preventExtensions | seal | freeze |
| :------------- | :--- | :---------------- | :--- | :----- |
| 增加新属性     | 可   |                   |      |        |
| 移除属性       | 可   | 可                |      |        |
| 更改属性       | 可   | 可                | 可   |        |
| 子对象属性操作 | 可   | 可                | 可   | 可     |

<a href="https://javascript.plainenglish.io/object-freeze-vs-object-seal-vs-object-preventextensions-e78ef3a24201" target="_blank" >见</a>

## 前端工程化

### 是什么

1. 通过`制定规范`、`借助工具和框架`, 解决前端开发, 以及前后端协作过程中的`痛点和难度问题`,`提高研发效率`

### 为什么

1. 随着需求的增加，前端也变成大前端，还要做 App、小程序以及各种端。
2. 在这种需求日增的情况下，必须得考虑一种新的方式，优化前端的开发工作，
3. 例如，`解决代码冗余`，`项目可维护性`，`提升版本迭代速度`等等一系列的问题。前端工程化的概念也就是在这中情况下被提出了。

### 如何实施前端工程化

1. 前端后分离
2. 使用 webpack 实现项目构建
3. 使用 babel 完成 javascript 编译
4. CSS 预编译
5. 组件化
6. 模块化开发
7. 本地开发环境/模拟数据
8. 规范化约束
9. 项目部署

## npm run 做了什么

```js
// package.json; -> node_modules/.bin/ ->对应的可执行文件执行

// 在安装依赖的时候，是通过npm install xxx来执行的，
// 例如npm install @vue/cli-service,npm在安装这个依赖的时候，
// 就会在node_modules/.bin/目录中创建好vue-cli-service为名的几个可执行文件了【不同系统对应不同的可执行文件】
// .bin目录下的文件不是任何一个npm包。目录下的文件，表示这是一个个软连接，打开文件可以看到文件顶部写着#!/bin/sh,表示这是一个脚本

// 当使用 npm run serve 执行 vue-cli-service serve时，
// 虽然没有安装 vue-cli-service的全局命令，但是npm 会到 ./node_modules/.bin中找到 vue-cli-service 文件作为 脚本来执行，
// 则相当于执行了 ./node_modules/.bin/vue-cli-service serve（最后的 serve 作为参数传入）
```

## npm install

**1. 检查配置**

1. 项目级别的.npmrc 文件 >
2. 用户级别的.npmrc 文件 >
3. 全局的.npmrc 文件 >
4. npm 内置的.npmrc 文件;

**2、没有 lock 文件**

1. `分析`：分析依赖关系，这是因为我们包会依赖其他的包，并且会多个包之间产生相同的依赖的关系。
2. `下载`：从 registry 仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）。
3. `缓存`：获取到压缩包后会对压缩包进行缓存（从 npm5 开始有的）。
4. `解压缩`：将压缩包解压到项目的 node_modules 文件夹中（前面我们讲过，require 的查找顺序会在该包下面查找）。

**3、有 lock 文件**

1. `比对`：检测 lock 中包的版本是否和 package.json 中一致（会按照 semver 版本规范检测）。
2. `无缓存`：不一致，那么会重新构建依赖关系，直接会走顶层的流程。
3. `有缓存`：一致的情况下，会去优先查找缓存。没有找到，会从 registry 仓库下载，直接走顶层流程。
4. `查找到`：会获取缓存中的压缩文件，并且将压缩文件解压到 node_modules 文件夹中。

## 实现 jsonp，传入 URL，callback 和 callbackName 三个参数

```js
function jsonp(url, callbackName, callback) {
  return new Promise((resolve, reject) => {
    try {
      let str = `${url}?callback=${callbackName}`;
      {
        /* 创建标签 */
      }
      let scriptEle = document.createElement('script');
      scriptEle.type = 'text/javascript';
      scriptEle.src = str;
      {
        /* 监听加载 */
      }
      scriptEle.addEventListener('load', callback);
      {
        /* 回调清理 */
      }
      window[callbackName] = function (data) {
        resolve(data);
        document.body.removeChild(scriptEle);
      };
      document.body.appendChild(scriptEle);
    } catch (err) {
      reject(err);
    }
  });
}

jsonp('http://127.0.0.1:3000/home', 'fun1', () => {
  console.log('加载成功');
}).then((res) => {
  console.log(res);
});
```

## 原生 js 实现动态加载 js 文件?

```js
function loadScript(src, attrs) {
  return new Promise((resolve, reject) => {
    try {
      // 创建标签
      let scriptEle = document.createElement('script');
      // 类型
      scriptEle.type = 'text/javascript';
      // src
      scriptEle.src = src;
      // 增加属性
      for (let key in attrs) {
        scriptEle.setAttribute(key, attrs[key]);
      }
      // 监听完成
      scriptEle.addEventListener('load', function () {
        resolve('成功');
      });
      // 挂载后加载
      document.body.appendChild(scriptEle);
    } catch (err) {
      reject(err);
    }
  });
}
loadScript('http://cdn.staticfile.org/jquery/1.6.2/jquery.min.js', { async: true }).then((res) => {
  console.log(res);
});
```

## js 中的 for 循环注意点？

```js
// 多个判断条件以最后一个为准
// 最后一个是 j < 9
for (var i = 0, j = 0; i < 5, j < 9; i++, j++) {
  console.log(i, j);
}
// 0 0
// 1 1
// 2 2
// 3 3
// 4 4
// 5 5
// 6 6
// 7 7
// 8 8
// 最后一个是  i < 5
for (var i = 0, j = 0; j < 9, i < 5; i++, j++) {
  console.log(i, j);
}
// 0 0
// 1 1
// 2 2
// 3 3
// 4 4
```

## new 操作符和点运算符的优先级

```js
function Foo() {
  getName = function () {
    console.log(1);
  }; //会修改全局的下的getName
  return this; // 构造函数的返回值值得注意，如果是引用类型，则得到引用数据，null除外
}
Foo.getName = function () {
  console.log(2);
};
Foo.prototype.getName = function () {
  console.log(3);
};
var getName = function () {
  console.log(4);
};
function getName() {
  console.log(5);
}

//请写出以下输出结果：
Foo.getName(); //2
getName(); // 4
Foo().getName(); // 1
getName(); // 1
new Foo.getName(); // 2 这里是new了一个Foo.getName函数，并没有先执行Foo.getName()在去执行new操作
new Foo().getName(); // 3 (new Foo()).getName() 此时的getName是找到Foo构造函数的原型对象上的getName属性
new new Foo().getName(); // 3  new ((new Foo()).getName)();
/*******************升级版********************/
// function Foo() {
// 		this.getName = function() {
// 			console.log(3);
// 			return {
// 				getName: getName//这个就是第六问中涉及的构造函数的返回值问题
// 			}
// 		};//这个就是第六问中涉及到的， JS 构造函数公有方法和原型链方法的优先级
// 		getName = function() {
// 			console.log(1);
// 		};
// 		return this
// 	}
// 	Foo.getName = function() {
// 		console.log(2);
// 	};
// 	Foo.prototype.getName = function() {
// 		console.log(6);
// 	};
// 	var getName = function() {
// 		console.log(4);
// 	};

// 	function getName() {
// 		console.log(5);
// 	} //答案：
// 	Foo.getName(); //2
// 	getName(); //4
// 	console.log(Foo())
// 	Foo().getName(); //1
// 	getName(); //1
// 	new Foo.getName(); //2
// 	new Foo().getName(); //3
//             //多了一问
// 	new Foo().getName().getName(); //3 1
// 	new new Foo().getName(); //3
// https://blog.csdn.net/weixin_34146986/article/details/92386841
```

## new 一个构造函数，如果函数返回不同类型的值，结果会如何?

new 的原理： 最后要判断构造函数返回值是不是个对象，不是对象是对象返回这个值，不是对象，返回构造函数的实例

```js
null instanceof Object; // false
Object instanceof null; // 报错，instanceof 的右侧必须是一个对象
// Uncaught TypeError: Right-hand side of 'instanceof' is not an object
```

### 什么都不返回

```js
function Person() {}

let p1 = new Person();
console.log(p1); //Person {}
```

### 返回一个新的对象

```js
function Person() {
  return {
    name: '1234',
  };
}

let p1 = new Person();
console.log(p1); //{name: '1234'}
```

### 返回一个原始值

```js
function Person() {
  return 111;
}

let p1 = new Person();
console.log(p1); // Person {}
```

### 返回 null

```js
function Person() {
  return null;
}

let p1 = new Person();
console.log(p1); // Person {}
```

### 返回 true

```js
function Person() {
  return true;
}

let p1 = new Person();
console.log(p1); // Person {}
```

### 返回 this

```js
function Person() {
  // 构造函数this指的是对象实例
  return this;
}

let p1 = new Person();
console.log(p1);
// Person {}

// 但是 this instanceof Object true, 这里涉及到this指向问题
```

## 为什么要用 apply/call 这两个函数

1. 说白了就是“拿来主义”、“借刀杀人”的功效，
2. 比如我想做什么事，我不会不要紧，只要有人会就可以实现。
3. 在程序里面就是，现在假如你想用什么方法，但是当前对象没有，你可以选择拓展，自己造一个这样的方法，但是你也可以直接拿来用

有时候这样使用更方便，我们只需要对象和回调方法即可，按照一般的说法就是：call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。

<a href="https://segmentfault.com/q/1010000006732812" target="_blank" >讲真，为什么要用 apply 和 call 这两个函数？</a>

## CSS

### height/width

width 中的 max-content,min-content,fit-content 的区别

1. `max-content` 实验性 设置为允许的最大高度。
2. `min-content` 实验性 设置为允许的最小高度。
3. `available` 实验性 包含块高度减去当前元素的边距，边框和填充。
4. `fit-content` 实验性 将 fill-content 公式中的可用位置替换为特定的参数以进行使用，如：`min(max-content, max(min-content, ))`

### width 属性 100%和 auto 的区别

1. `width：100%`
   100%表示子元素的宽度和父元素的宽度相等，其中并不包括子元素内外边距以及边框的值，为子元素真正的宽度

2. `width：auto`
   auto 表示子元素的 宽度+内边距+外边距+边框 才等于父元素的宽度

**注意：上述父元素的宽度都是父元素真正的宽度，即父元素 width 属性值**
————————————————
版权声明：本文为 CSDN 博主「Tie_may」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Tie_may/article/details/113761173

### vertical-align: middle

Vertical-align 被`用于垂直对齐 inline 元素`，`也就是 display 值为 inline 和 inline-block 的元素`

CSS 的属性 vertical-align 用来指定`行内元素（inline）`或`表格单元格（table-cell）元素`的垂直对齐方式。

<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" >MDN</a>

### will-change

1. `不要将 will-change 应用到太多元素上：`浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。
2. `有节制地使用：`通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了 will-change 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换 will-change 的值。
3. `不要过早应用 will-change 优化：`如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是`作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题`。`过度使用 will-change 会导致大量的内存占用，并会导致更复杂的渲染过程`，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。
4. `给它足够的工作时间：`这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。

### z-index

1. `auto`
   盒子不会创建一个新的本地堆叠上下文。在当前堆叠上下文中生成的盒子的堆叠层级和父级盒子相同。

2. `<integer>`
   `<integer>`（整型数字）是生成的盒子在当前堆叠上下文中的堆叠层级。

**此盒子也会创建一个堆叠层级为 0 的本地堆叠上下文。这意味着后代（元素）的 z-indexes 不与此元素的外部元素的 z-indexes 进行对比。**

### 介绍下盒模型

<img src="http://t-blog-images.aijs.top/img/202301311827280.webp" />

<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model" target="_blank" >见</a>

### CSS 是怎么工作的

1. `浏览器载入 HTML 文件（比如从网络上获取）`。
2. `将 HTML 文件转化成一个 DOM（Document Object Model）`，DOM 是文件在计算机内存中的表现形式，下一节将更加详细的解释 DOM。
3. `接下来，浏览器会拉取该 HTML 相关的大部分资源`，比如嵌入到页面的图片、视频和 CSS 样式。JavaScript 则会稍后进行处理，简单起见，同时此节主讲 CSS，所以这里对如何加载 JavaScript 不会展开叙述。
4. `浏览器拉取到 CSS 之后会进行解析`，`根据选择器的不同类型（比如 element、class、id 等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id 选择器等）应用在对应的 DOM 的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）`。
5. 上述的规则应用于渲染树之后，`渲染树会依照应该出现的结构进行布局`。
6. `网页展示在屏幕上（这一步被称为着色）`。

<img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/How_CSS_works/rendering.svg" style={{ width: "500px", maxWidth: "100%" }} />
<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works" target="_blank" >见</a>

### 当浏览器遇到无法解析的 CSS 代码会发生什么

浏览器什么也不会做，继续解析下一个 CSS 样式！

<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works#%E5%BD%93%E6%B5%8F%E8%A7%88%E5%99%A8%E9%81%87%E5%88%B0%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84_css_%E4%BB%A3%E7%A0%81%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88" target="_blank" >见</a>

### 层叠、优先级和继承

层叠相关因素：`资源顺序、优先级 、重要程度`

1. `样式表层叠`——简单的说，就是 CSS 规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。
2. `优先级` 浏览器是根据`优先级`来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度：`越具体优先级越高`,权重越大，优先级越高
3. `继承`也需要在上下文中去理解——一些设置在父元素上的 CSS 属性是可以被子元素继承的，有些则不能

### !important

强烈建议除了非常情况不要使用它
覆盖 `!important` 唯一的办法就是另一个 `!important` 具有相同优先级而且顺序靠后，或者更高优先级。

## 优化

### 从 performanceAPI 来讲

一大堆...,简单说要个几分钟，展开来讲几十分钟，几个小时

### 协议优化

1. http2 优于 http1
2. http3 优于 http2

### 加载优化

1. 预加载
2. 懒加载 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" >Intersection Observer</a>
3. 按需加载
4. 延迟加载、异步加载
5. 压缩（webpack 来讲 html、css、js、json、image 都可以压缩）
6. CDN

### 渲染优化

1. css、htm 嵌套减少
2. react-native 里有个视图拍平优化
3. 回流和重绘
4. 按需渲染
5. useCallback、useMemo、shouldComponentUpdate 浅比较
6. 局部渲染、局部刷新

### 缓存优化

1. 强缓存
2. 协商缓存
3. 闭包数据缓存

### 更新优化

1. 虚拟 dom,批量更新
2. 按需更新 immutable.js、immerjs

### 上线后收集用户信息

1. performanceAPI
2. web-vital

### 收集后分析处理

1. 浏览器 performance 窗口 分析 longtask
2. 浏览器 mermory monitor 分析内存的释放情况
3. 浏览器 Record coverage while performance tracing <a href="https://blog.csdn.net/qq_43127921/article/details/122151253" target="_blank" >见</a>
4. lighthouse 插件
5. Web Vitals 插件

### 页面可见性 API

document.hidden/visibilitychange

1. 网站有图片轮播效果，只有在用户观看轮播的时候，才会自动展示下一张幻灯片。
2. 显示信息仪表盘的应用程序不希望在页面不可见时轮询服务器进行更新。
3. 页面想要检测是否正在渲染，以便可以准确的计算网页浏览量
4. 当设备进入待机模式时，网站想要关闭设备声音（用户按下电源键关闭屏幕）

### 按需拷贝

immerjs

## 原生 js 深拷贝/浅拷贝

### 浅拷贝

1. 所有标准的内置对象复制操作创建的是浅拷贝而不是深拷贝
   1. `展开语法`
   2. `Array.prototype.concat()`、`Array.prototype.slice()`、`Array.from()`
   3. `Object.assign()` 和 `Object.create()`

### 深拷贝

1. 对象的深拷贝是指其属性与其拷贝的源对象的属性不共享相同的引用（指向相同的底层值）的副本。
2. 因此，当你更改源或副本时，可以确保不会导致其他对象也发生更改；
3. 不会出现无意中对源或副本造成意料之外的更改

<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Deep_copy" target="_blank" >深拷贝</a>

<a href="https://developer.mozilla.org/zh-CN/docs/web/api/structuredClone" target="_blank" >window.structuredClone</a>

## react-native

### react-native 新特性

1. 恢复 PropTypes
2. 默认情况下为 TypeScript
3. 使用 Flexbox Gap 简化布局
4. 受 Web 启发,对可访问性、样式和事件进行增强
5. 开发者体验改进
6. 新架构更新

<img src="http://t-blog-images.aijs.top/img/202302182122000.webp" />

<a href="https://reactnative.dev/blog" target="_blank" >https://reactnative.dev/blog</a>

### react-native 与原生的通信

<a href="/#/post/2023-02-17rn-native" target="_blank" >见：2023-02-17rn-native</a>

## 数组

1. 数组中有哪些方法

   1. 构造方法
   2. 静态方法

      1. Array.from()： 从数组类对象或可迭代对象创建一个新的 Array 实例。
      2. Array.isArray()：如果参数是数组则返回 true ，否则返回 false 。
      3. Array.of()： 创建一个新的 Array 实例，具有可变数量的参数，而不管参数的数量或类型。

   3. 在访问索引之前执行 `in 检查`，并且`不将空槽与 undefined 合并`：

      1. copyWithin()
      2. concat()
      3. every()
      4. filter()
      5. flat()
      6. flatMap()
      7. indexOf()
      8. forEach()
      9. lastIndexOf()
      10. map()
      11. reduce()
      12. reduceRight()
      13. reverse()
      14. slice()
      15. some()
      16. sort()

   4. 将空槽视为 undefined：

      1. join()
      2. keys()
      3. values()
      4. entries()
      5. fill()
      6. find()
      7. findIndex()
      8. findLast()
      9. findLastIndex()
      10. includes()
      11. group() (en-US)
      12. groupToMap() (en-US)
      13. toLocaleString()

   5. 创建新数组的

      1. concat()
      2. map()
      3. filter()
      4. slice()
      5. splice()（构造返回的已删除元素数组）
      6. flat()
      7. flatMap()

   6. 可以对原数组进行修改：

      1. shift() // 去掉
      2. unshift() // 增加
      3. push()
      4. pop()
      5. splice()
      6. fill()
      7. reverse()
      8. sort()
      9. copyWithin()
