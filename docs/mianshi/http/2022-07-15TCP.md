---
sidebar_position: 12
title: 前端基础-TCP ⚡️
---

## TCP 的特性

1. TCP 提供⼀种`⾯向连接的`、`可靠的`、`字节流 `服务
2. 在⼀个 TCP 连接中，`仅双⽅进⾏彼此通信`。⼴播和多播不能⽤于 TCP
3. TCP 使⽤`校验`、`确认`和`重传机制`来保证可靠传输
4. TCP 使用`分节排序`和`累积确认`，来保证数据的顺序不变, 和⾮重复
5. TCP 使⽤`滑动窗⼝`来实现流量控制，通过动态改变窗⼝的⼤⼩，进⾏拥塞控制

## TCP、UDP 的区别

<!-- <img src="http://t-blog-images.aijs.top/img/202302031618179.webp" style="object-fit: cover" /> -->

1. TCP 是一种面向连接的单播协议,在 TCP 中,并不存在多播、广播的这种行为，`因为 TCP 报文段中能明确发送方和接受方的 IP 地址`。
2. UDP 是无连接的 ,因为使用 UDP 协议的发送者和接受者之间不必存在任何长期的关系。它们没有建立连接过程，简单来说就是`发送即结束`

| 协议 | 可靠性                   | 双⼯性      | 连接性   | 有序性               | 有界性         | 拥塞控制 | 传输速度 | 量级 | 头部⼤⼩   |
| :--- | :----------------------- | :---------- | :------- | :------------------- | :------------- | :------- | :------- | :--- | :--------- |
| TCP  | 可靠(重传机 制)          | 全双⼯(1:1) | ⾯向连接 | 有序(通过 SYN 排 序) | ⽆, 有粘包情况 | 有       | 慢       | 低   | 20~60 字节 |
| UDP  | 不可靠(丢包后 数据丢 失) | n:m         | ⽆连接   | ⽆序                 | 有 ⽆粘包      | ⽆       | 快       | ⾼   | 8 字节     |

**意义不同**

1. TCP: `Transmission Control Protocol`,传输控制协议
2. UDP: `User Datagram Protocol`,用户数据报协议

**双工、连接、可靠**

1. `双⼯性`：TCP 全双工（1:1），UDP(n:m)
2. `连接性`：TCP 面向连接，UDP 无链接
3. `可靠性`：TCP 可靠，有重传机制，UDP 不可靠，丢了就丢了

**有序、有界、有控制**

1. `有序性`：TCP 有序，通过 SYN 排序，UDP 无序
2. `有界性`：TCP 无界，有粘包情况，UDP 有消息边界，无粘包
3. `有控制`：TCP 有拥塞控制，UDP 没有拥塞控制

**有内容，也要有速度**

1. `头⼤`：TCP 头部大小 20-60 字节，UDP 头部大小 8 个字节
2. `量小`：TCP 传输量级低于 UDP
3. `传的慢`：TCP 相对于 UDP 而言要慢

## 如何理解 UDP 的“无连接”特性？

<a href="https://www.dandelioncloud.cn/article/details/1505563355480944641" target="_blank" >如何理解 UDP 的“无连接”特性？</a>

## TCP 粘包是怎么回事，如何处理?

### 是什么

可以参⻅⽹上流传⽐较⼴的⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:

1. 先接收到 data1, 然后接收到 data2 .
2. 先接收到 `data1 的部分数据`, 然后接收到 `data1 余下的部分`以及 `data2 的全部`.
3. 先接收到了 `data1 的全部数据`和 `data2 的部分数据`, 然后接收到了 `data2 的余下的数据`.
4. ⼀次性接收到了 data1 和 data2 的全部数据.

`其中的 2,3,4 就是我们常⻅的粘包的情况`.

### 为什么

1. 默认情况下, TCP 连接会`启⽤延迟传送算法` (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有`多个数据`发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), `这样可以减少 IO 消耗提⾼性能`.
2. 如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了.
3. 但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.

### 对于处理粘包的问题, 常⻅的解决⽅案有:

1. 关闭 Nagle 算法 （`场景：数据较大，频率不是特别高的场景`）
2. 多次发送之前间隔⼀个等待时间 （`场景：交互频率低的场景`）
3. 进⾏封包/拆包（`场景：发送特征数据，收到后按特征数据进行分割`）

## 为什么 udp 不会粘包？

1. `消息提取位` `TCP 协议是⾯向流的协议`，`UDP 是⾯向消息的协议 UDP 段都是⼀条消息`，应⽤程序必须`以消息为单位提取数据`，不能⼀次提取任意字节的数据
2. `消息边界` UDP`具有保护消息边界`，在每个 UDP 包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易 进⾏区分处理了。
3. `数据丢了不管` `传输协议`把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息`。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收

## TCP 三次握手

所谓三次握⼿(Three-way Handshake)，是指建⽴⼀个 TCP 连接时，`需要客户端和服务器总共发送3个包`。

三次握⼿的⽬的是连接服务器指定端⼝，建⽴ TCP 连接，并同步连接双⽅的序列号和确认号，交换 TCP 窗⼝⼤⼩信息。

1. 客户端：`SYN标志+序列号`,进入`SYN_SEND`状态
2. 服务端：`SYN标志+序列号+确认标识+确认序号`, 进入`SYN_RCVD`状态
3. 客户端：`确认标识+确认序号`，进入`ESTABLISHED`状态

:::details 点击查看更多

在 socket 编程中，客户端执⾏ connect() 时。将触发三次握⼿。

1. `第⼀次握⼿(SYN=1, seq=x)`: 客户端发送⼀个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X,保存在包头 的序列号(Sequence Number)字段⾥。 发送完毕后，客户端进⼊ SYN_SEND 状态。 `SYN标志+序列号+SYN_SEND`

2. `第⼆次握⼿(SYN=1, ACK=1, seq=y, ACKnum=x+1)`: 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择⾃⼰ ISN 序列号，放到 Seq 域 ⾥，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进⼊ SYN_RCVD 状态。

3. `第三次握⼿(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确 定字段中发送给对⽅`，并且在数据段放写 ISN 的+1 发送完毕后，客户端进⼊ ESTABLISHED 状态，当服务器端接收到这个包时，也进⼊ ESTABLISHED 状态，TCP 握⼿ 结束。 三次握⼿的过程的示意图如下：

<img src="http://t-blog-images.aijs.top/img/20220715170016.webp" />

:::

## TCP 四次握手

✨ TCP 的连接的拆除需要发送四个包，因此称为四次挥⼿(Four-way handshake)，也叫做改进的三次握⼿。`客户端或服务器均可主动发起挥⼿动作`，在 socket 编程中，任何⼀⽅执⾏ close() 操作即可产⽣挥⼿操作。

1. 客户端：`结束标识+序列号`,进⼊ `FIN_WAIT_1` 状态
2. 服务端：`确认标识+确认序号`,进⼊ `FIN_WAIT_1` 状态
3. 服务端：`结束标识+序列号`,进⼊ `FIN_WAIT_2` 状态
4. 客户端：`确认标识+确认序号`,进⼊ `TIME_WAIT` 状态
5. 后 续：服务端：进⼊ `CLOSED` 状态，客户端：`两个最⼤段⽣命周期`, 进⼊ `CLOSED` 状态

:::details 点击查看更多

1. `第⼀次挥⼿(FIN=1，seq=x)` 假设客户端想要关闭连接，客户端发送⼀个 FIN 标志位置为 1 的包，表示⾃⼰已经没有数据可以发送了，但是仍然 可以接受数据。 发送完毕后，客户端进⼊ FIN_WAIT_1 状态。
2. `第⼆次挥⼿(ACK=1，ACKnum=x+1)` 服务器端确认客户端的 FIN 包，发送⼀个确认包，表明⾃⼰接受到了客户端关闭连接的请求，但还没有准备好关闭 连接。 发送完毕后，服务器端进⼊ CLOSE_WAIT 状态，客户端接收到这个确认包之后，进⼊ FIN_WAIT_2 状态，等待服务 器端关闭连接。
3. `第三次挥⼿(FIN=1，seq=y)` 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。 TCP ⾯试题 54 发送完毕后，服务器端进⼊ LAST_ACK 状态，等待来⾃客户端的最后⼀个 ACK。
4. `第四次挥⼿(ACK=1，ACKnum=y+1)` 客户端接收到来⾃服务器端的关闭请求，发送⼀个确认包，并进⼊ TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进⼊ CLOSED 状态。
5. 客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。 四次挥⼿的示意图如下：

<img src="http://t-blog-images.aijs.top/img/20220715170027.webp" />

:::

## 请求连接是三次，断开连接是四次

**简言之：收到后的确认应答，和结束应答是分开的**

1. 服务端：`确认标识+确认序号`,进⼊ `FIN_WAIT_1` 状态
2. 服务端：`结束标识+序列号`,进⼊ `FIN_WAIT_2` 状态

分为两个，目的是在服务端发送完数据后，然后进行发送关闭信号

## 三次握手改为两次

采用三次握手是为了`防止失效的连接请求报文段突然又传送到主机B，因而产生错误`。

失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。

考虑这样一种特殊情况：`主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。`

采用两次握手不行，原因就是上面说的`失效的连接请求`的特殊情况。

**不是很恰当的例子**

1. 例子 1（3 次握手）：朋友：来吃饭 -> 你：好咧，等我哈 -> 朋友：👌。
2. 例子 2（2 次握手）：朋友：来吃饭 -> 你（第二天你看到了）：好咧，等我哈。 朋友不在家（吃闭门羹）

## 参考链接

<a href="https://blog.csdn.net/nk298120/article/details/116596086" target="_blank" >TCP 三次握手如果使用二次握手代替则会出现的问题</a>
