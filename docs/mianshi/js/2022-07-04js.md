---
sidebar_position: 20
title: 前端基础-js算法 ⚡️
---

## 实现单例

### 通过构造函数

```js
class Singleton {
  constructor() {
    console.log('this', this);
    if (!Singleton.instance) {
      // 将 this 挂载到单例上
      Singleton.instance = this;
    }
    return Singleton.instance;
  }
}
const a = new Singleton();
const b = new Singleton();
console.log(a === b);
```

### 通过静态方法

```js
class Singleton {
  static instance = null;

  static getInstance() {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}
const a = Singleton.getInstance();
const b = Singleton.getInstance();
console.log(a === b);
```

## 字符串相关

<a href="/#/post/2022-05-03string" target="_blank" >见：2022-05-03string</a>

## 深度操作

### 深拷贝

#### structuredClone

<a href="https://developer.mozilla.org/zh-CN/docs/web/api/structuredClone" target="_blank" >见</a>

```js
// Create an object with a value and a circular reference to itself.
const original = { name: "MDN" , hello: {world: true}};
original.itself = original;

// Clone it
const clone = structuredClone(original);

console.log(clone !== original); //  true  the objects are not the same (not same identity)
console.log(clone.name === "MDN"); // true  they do have the same values
console.log(clone.itself === clone); // true and the circular reference is preserved
console.log(clone.hello === original.hello) false
```

#### 深度克隆

```js
function isBase = (val) => {
  return val === null || typeof val !== "object"
}

function isObject(obj) {
  return Object.prototype.toString.call(obj) == "[object Object]";
}

function isArray(obj) {
  return Object.prototype.toString.call(obj) == "[object Array]";
}

function deepClone(obj) {
  let result;
  if (isBase(obj)) {
    //基本数据类型，直接赋值
    result = obj;
  } else {
    // 非基本数据类型，遍历赋值
    result = isArray(obj) ? [] : {}; // 空对象接收
    for (let i in obj) {
      // prettier-ignore
      result[i] = isObject(obj[i]) || isArray(obj[i]) ? deepClone(obj[i]) : obj[i];
    }
  }
  return result;
}
```

#### 深比较

实现一个 compare 函数，比较两个对象是否相同<a href="https://www.jianshu.com/p/0828ded57b19#:~:text=%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83-,%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A,-//%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6" target="_blank" >见</a>

```js
/**
 * 原理：
 * 1. 基本数据类型比较
 * 2. 复合类型，递归每个值依次比较
 **/
// 基础类型/null的数据类型，可以直接比较
const isBase = (val) => val === null || typeof val !== 'object';

function deepCompare(a, b) {
  // 基本数据类型
  if (isBase(a) || isBase(b)) {
    return a === b || (isNaN(a) && isNaN(b));
  }
  // Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。
  const propsA = Object.getOwnPropertyDescriptors(a);
  const propsB = Object.getOwnPropertyDescriptors(b);
  // 键是否长度一致
  if (Object.keys(propsA).length !== Object.keys(propsB).length) {
    return false;
  }
  // 键对应相等
  return Object.keys(propsA).every((key) => deepCompare(a[key], b[key]));
}
```

#### 深度获取差异化

```js
// 是否为基础数据类型
const isBase = (val) => val === null || typeof val !== 'object';
const isNumber = (val) => toString.call(v) === '[object Number]';
// 深度比较两个对象的差异
function deepDiffCompare(a, b, diffResult, k = 'root') {
  // 基本数据类型
  if (isBase(a) || isBase(b)) {
    // return a === b;
    if (a !== b) {
      diffResult[k] = b;
    } else {
      // console.log("数据一致忽略");
    }
  } else {
    const propsA = Object.keys(a);
    const propsB = Object.keys(b);
    const uukeys = new Set([...propsA, ...propsB]);
    // 键对应相等
    uukeys.forEach((key) => deepDiffCompare(a[key], b[key], diffResult, key));
  }
}

// 必填数据
const requireds = ['sex'];
// 模拟数据
const old = { name: 1, age: 2, dog: { name: '小狗', do: '汪汪叫' } };
const newValue = { name: 1, age: 2, sex: 1 };
// 执行比较测试
handleCompare(old, newValue);

// 这里涉及到函数声明提升，写在后面不影响使用
function handleCompare(old, newValue, onChange) {
  let diffResult = {};

  deepDiffCompare(old, newValue, diffResult);

  // console.log("diffResult", diffResult);
  // 变化的数据，在必填数据中，则hasChange为true, 否则为false
  const hasChange = Object.keys(diffResult).some((k) => requireds.includes(k));

  // console.log("hasChange", hasChange);
  hasChange && onChange?.();
}

// vue中使用
// watch: {
//   'submitForm': {
//      handler(val, oldVal) {
//       console.log('c changed')
//       handleCompare(oldVal, val, ()=>{
//         this.clearTableData()
//       })
//     },
//     deep: true
//   }
//  }
```

#### 深度拼接

实现 `json.stringify`

<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON#polyfill" target="_blank" >MDN JSON.stringify js 实现</a>

<a href="/#/post/2023-02-27json" target="_blank" >见：2023-02-27json</a>

#### 深度解析

实现 `json.parse`

```js
function parse(sJSON) {
  return eval('(' + sJSON + ')');
}
```

## 闭包

### uuid

```js
const getUniqueID = ((id) => () => {
  id += 1;
  return id;
})(-1);

// getUniqueID
// () => {
//   id += 1;
//   return id;
// }
```

### 操作后防抖

```js
// 去抖动原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时.
// 方法1
const debounce = function (fn, delay) {
  let timer = null; // 闭包维护一个timer
  return (...args) => {
    // 柯里化
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn?.apply(this, args); // this指向window
    }, delay);
  };
};

// 测试

let biu = function () {
  console.log('biu biu biu', new Date().getTime());
};
let boom = function () {
  console.log('boom boom boom', new Date().getTime());
};

var a = setInterval(debounce(biu, 500), 1000);
var b = setInterval(debounce(boom, 2000), 1000);
setTimeout(() => {
  clearInterval(a);
  clearInterval(b);
}, 10000);
```

### 执行一次后防抖

```js
function debounceStart(fn, delay = 0) {
  let immediate = true;
  let timerId = null;
  return function (...args) {
    if (immediate) {
      fn.apply(this, args);
      immediate = false;
    }
    clearTimeout(timerId);
    timerId = setTimeout(() => {
      immediate = true;
    }, delay);
  };
}
```

### 节流

```js
const throttle = (fn, delay = 500) => {
  let allow = true; // 守门员，delay秒钟放进去一个球

  return (...args) => {
    if (!allow) return;
    allow = false;

    setTimeout(() => {
      fn.apply(this, args);
      allow = true;
    }, delay);
  };
};
```

### 接口数据缓存

## this 指向

<a href="https://juejin.cn/post/6977563249650696206" target="_blank" >https://juejin.cn/post/6977563249650696206</a>

### call

- 语法

```js
function.call(thisArg, arg1, arg2, ...)

```

call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 即：可以改变当前函数的 this 指向；还会让当前函数执行。

```js
// 1. 给函数原型添加mycall方法，创建一个上下文对象context，如果传入的对象不存在时，将指向全局window。
// 2. 通过给context添加fn属性，context的fn引用调用该方法的函数fun，并执行fun。
// 3. 执行完成之后删除该属性fn。
Function.prototype.mycall = function (context, ...args) {
  // prettier-ignore
  context = context == null || context == undefined ? window : new Object(context);
  context.fn = this;
  let r = context.fn(...args);
  delete context.fn;
  return r;
};

function fun() {
  console.log(this.name, arguments);
}
let obj = { name: 'clying' };
fun.mycall(obj, 'deng', 'deng');
```

### apply

- 语法

```js
apply(thisArg);
apply(thisArg, argsArray);
```

1. 与 call 方法类似，call 方法接收的是一个参数列表，而 apply 方法接收的是一个包含多个参数的数组。
2. 用法 将函数中的 this 指向传入的第一个参数，第二个参数为数组

```js
Function.prototype.myapply = function (context, args) {
  // prettier-ignore
  context = context == null || context == undefined ? window : new Object(context);

  context.fn = this;

  if (!args) return context.fn();
  // args 数组被转化成字符串
  let r = eval('context.fn(' + args + ')');
  delete context.fn;
  return r;
};
```

### bind

**更像是数据收集，通过柯里化，减少参数，方便后续调用**

1. bind() 方法`创建一个新的函数，不自动执行，需要手动调用 bind()` 。
2. 这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用
3. 用法将 obj 绑定到 fun 函数的 this 上，函数 fun 可以使用 obj 内部的属性，和传入的变量。

```js
// 应用于curry，要理解
Function.prototype.mybind = function (context) {
  let that = this;
  let bindargs = Array.prototype.slice.call(arguments, 1);
  // 产生闭包
  function fBind() {
    let args = Array.prototype.slice.call(arguments);
    // 1. 如果使用的是new，那么this会指向fBind实例，this作为当前实例传入
    // 2. 不是new的话，使用context上下文对象
    // prettier-ignore
    return that.apply( this instanceof fBind ? this : context, bindargs.concat(args)) // 通过闭包获取更多的参数;
  }

  return fBind;
};

// 测试1

function fun() {
  console.log(this.name, arguments);
}
let obj = {
  name: 'clying',
};
let b = fun.mybind(obj, 2);
b(3);
// clying Arguments(2) [2, 3]
//
//
//
//
// 测试2
function fun() {
  console.log(this.name, arguments);
}
let obj = {
  name: 'clying',
};
fun.prototype.age = 23;
let b = fun.mybind(obj, 3);
let instance = new b(4);
console.log(instance.age);
//undefined Arguments(2) [3, 4]
// 23
```

## Promise

<a href="https://blog.csdn.net/weixin_45774485/article/details/122462081" target="_blank" >手写 promise 的方法（all、race、allSettled、any、finally）</a>

### 手写 promise

<a href="https://juejin.cn/post/7194257890893365308" target="_blank" >5K 字 由浅入深聊聊 Promise 实现原理</a>

### Promise.all

- 要么返回全部 resolve 结果，要么返回一个 reject

```js
Promise.myAll = function (promises) {
  return new Promise((resolve, reject) => {
    if (!isArray(promises)) {
      return reject(new TypeError('arguments must be an array'));
    }

    let res = [];
    var resolvedCounter = 0;
    var promiseNum = promises.length;

    promises.forEach((promise, index) => {
      Promise.resolve(promise) // 防止你不是一个promise
        // 如果参数是一个原始值,或者是一个不具有then方法的对象,则Promise.resolve方法返回一个新的 Promise 对象,状态为resolved
        // @link https://wenku.baidu.com/view/8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html
        .then((data) => {
          resolvedCounter++;
          res.push(data);
          // 所有的都没有异常
          promiseNum === resolvedCounter && resolve(res);
        })
        .catch((err) => {
          // 捕获，直接返回
          reject(err);
        });
    });
  });
};
```

### Promise.race

- 不管 resolve, reject，见到就返回

```js
Promise.myRace = (promises) =>
  return new Promise((resolve, reject) => {
    promises?.forEach((promise) => {
      promise.then(resolve, reject);
    });
  });
```

### Promise.allSettle

- 全部结果，resolve, reject 都要

```js
Promise.myAllSettled = function (promises) {
  let len = promises.length;
  let count = 0;
  let result = new Array(len);

  return new Promise((resolve, reject) => {
    for (let p of promises) {
      Promise.resolve(p).then(
        (res) => {
          //成功：加入装状态列表
          result[count] = {
            //记录当前promise信息
            status: 'fullfilled',
            result: res,
          };
          if (++count == len) {
            //遍历完，走resolve
            resolve(result);
          }
        },
        (err) => {
          //失败：加入状态列表
          result[count] = {
            //记录当前promise状态信息
            status: 'rejected',
            result: err,
          };
          if (++count == len) {
            //遍历完依然走resolve
            reject(result);
          }
        }
      );
    }
  });
};
```

### Promise.any

- 要么没有 resolve 的,返回全部 reject 结果，要么有一个 resolve 的返回 resolve 结果(看上去和`Promise.all`刚好反过来了)

```js
Promise.myAny = function (promises) {
  let res = [],
    count = 0,
    len = promises.length;

  return new Promise((resolve, reject) => {
    for (let p of promises) {
      Promise.resolve(p).then(
        (res) => {
          resolve(res); // 只要有一个成功，就走resolve
        },
        (err) => {
          res[count] = err; // 遇到错误先不管，继续检查
          if (++count == len) {
            // 直到遇到成功的或检查完
            reject(res);
          }
        }
      );
    }
  });
};
```

### Promise.finally

- 无论哪个执行完，回调下

```js
Promise.prototype.myFinally = function (cb) {
  //cb就是要共同执行的逻辑
  return this.then(
    //谁调用finally，this就是谁
    (value) => Promise.resolve(cb()), //不管调用finally的promise是什么状态都会执行这个cb
    (error) => Promise.resolve(cb()) //不管调用finally的promise是什么状态都会执行这个cb
  );
};
```

### Promise.resolve

<a href="https://wenku.baidu.com/view/8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html" target="_blank" >见 Promise.resolve（）详解</a>

```js
Promise.prototype.myResolve = function (params) {
  return new Promise((resolve) => resolve(params));
};
```

### 阻断 resolve/reject 后面代码还会执行

<a href="https://www.freesion.com/article/68121031859/" target="_blank" >使用 Promise 过程中 resolve 或 reject 后，后面代码还会执行，默认加 return 较妥</a>

### 限制并发数量

```js
// 原理：将在用数量，限制在最大数量内的异步直接发，
// 限制外的现存到数组中，当在用数量减少时一个一个取出来运行
export class LimitPromise {
  private limit: number;        // 最大限制数
  private runningcount: number;        // 目前并发的数量
  private taskQueue: any[];     // 如果并发数等于最大限制，则把新加的异步操作用数组存起来

  constructor(limit: number) {
    this.limit = limit;
    this.runningcount = 0;
    this.taskQueue = [];
  }
  // 出队列
  private createTask(
    asyncFn: Function,
    args: any[],
    resolve: (value: unknown) => void,
    reject: (reason?: any) => void,
  ) {
    return () => {
      asyncFn(...args)
        .then(resolve)
        .catch(reject)
        .finally(() => {
          this.runningcount--; // 任务结束后，对任务队列进行出列，执行
          if (this.taskQueue.length) {
            let task = this.taskQueue.shift();
            task();
          }
        });

      this.runningcount++; // 在执行的数量
    };
  }
  // 入队列
  public call(asyncFn: Function, ...args: any[]) {
    // 这层promise令人费解，主要是为了提供resolve和reject给 limitP.call，
    // 这样limitP可以做些其他的事情，理论上没有必要
    return new Promise((resolve, reject) => {
      const task = this.createTask(asyncFn, args, resolve, reject); // 创建任务
      if (this.runningcount >= this.limit) { // 大于限制的存起来
        this.taskQueue.push(task);
      } else { // 否则直接执行
        task();
      }
    });
  }
}

let limitP = new LimitPromise(3)



// 测试
function sleep(sec: number) {
  console.log('..............');
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log('等待了' + sec + '秒');
      resolve('');
    }, sec * 1000);
  });
}

limitP.call(sleep, 1);
limitP.call(sleep, 2);
limitP.call(sleep, 3);
limitP.call(sleep, 4);
limitP.call(sleep, 5);
limitP.call(sleep, 6);
// https://stackblitz.com/edit/typescript-sdhev3?file=index.ts
```

### PromiseQueue

```js
// 入队列
// 出队列
class PromiseQueue {
  constructor(tasks, limit = 1) {
    this.tasks = tasks;
    this.limit = limit;
    this.running = [];
  }
  next() {
    return this.running.length < this.limit && this.tasks.length;
  }

  run() {
    while (this.next()) {
      let promise = this.tasks.shift(); // 更改tasks数组长度

      promise.then((data) => {
        this.run();
      });

      this.running.push(promise); // 更改running数组长度
    }
  }
}

// 接收一个promise数组，并发限制为3
const taskQueue = new PromiseQueue(tasks, 3);
taskQueue.run();

// 清理
// taskQueue = undefined
```

### async await 原理实现

<a href="https://juejin.cn/post/7007031572238958629#heading-15" target="_blank" >见</a>

<a href="https://juejin.cn/post/7195358576364224568" target="_blank" >仅“2k”字就能理解的 async/await 原理，摸个鱼的时间搞定它</a>

```js
// function* 这种声明方式 (function关键字后跟一个星号）会定义一个生成器函数 (generator function)，
// 它返回一个 Generator 对象
// generator对象由生成器函数生成

//接受一个Generator函数作为参数
function myAsync(gen) {
  // 返回一个函数
  return function () {
    // 返回一个promise
    return new Promise((resolve, reject) => {
      // 执行Generator函数
      // generator返回什么
      let g = gen();

      const next = (context) => {
        let res;
        try {
          res = g.next(context);
        } catch (error) {
          reject(error);
        }
        if (res.done) {
          // 这时候说明已经是完成了，需要返回结果
          resolve(res.value);
        } else {
          // 继续执行next函数,传入执行结果
          return Promise.resolve(res.value).then(
            (val) => next(val),
            (err) => next(err)
          );
        }
      };
      next();
    });
  };
}

// prettier-ignore
const getFetch = (nums) => new Promise((resolve) => {
  setTimeout(() => {
    resolve(nums + 1);
  }, 1000);
});

function* gen() {
  let res1 = yield getFetch(1);
  let res2 = yield getFetch(res1);
  let res3 = yield getFetch(res2);
  return res3;
}

const asyncGen = myAsync(gen /*传入generator */);

asyncGen().then((res) => {
  console.log(res);
}); // 4
```

## 数组

### 数组去重

<a href="https://blog.csdn.net/weixin_45663702/article/details/123504807" target="_blank" >常见前端面试题--数组去重</a>

方案 1:

```js
function unique(arr) {
  return Array.from(new Set(arr));
}

// prettier-ignore
let arr = [ 1, 1, "true", true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, "NaN", 0, 0, "a", "a", {}, {},];

console.log(unique(arr));
// ['1', 'true', true, 15, undefined, null, null, NaN, 'NaN', 0, 'a', {}, {}]
//无法去掉'{}'空对象
```

方案 2:

```js
function unique(arr) {
  return arr.filter(function (item, index, arr) {
    // 当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
// prettier-ignore
let arr = [ 1, 1, "true", true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, "NaN", 0, 0, "a", "a", {}, {},];

console.log(unique(arr));
// [1, 'true', true, 15, false, undefined, null, 'NaN', 0, 'a', {}, {}]
// {}不能去重
```

方案 3:

```js
function unique(arr) {
  return arr.reduce((prev, cur) => (prev.includes(cur) ? prev : [...prev, cur]), []);
}

// prettier-ignore
let arr = [ 1, 1, "true", true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, "NaN", 0, 0, "a", "a", {}, {},];

console.log(unique(arr));
// [1, 'true', true, 15, false, undefined, null, NaN, 'NaN', 0, 'a', {}, {}]
```

### 将奇数排在前面，偶数排在后面

要求时间复杂度 O(n)。空间复杂度 O(1)（不能用 splice）

```js
var testAry = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var newAry = [];

testAry.forEach((item, i) => {
  let n = Number(item);
  if (n % 2 == 0) {
    newAry.push(n);
  } else {
    newAry.unshift(n);
  }
});

console.log(newAry); //["9","7","5","3","1","2","4","6"]
```

### 数组转树结构

```js
const arr = [
    { id: 1, pid: 0 },
    { id: 2, pid: 1 },
    { id: 3, pid: 1 },
    { id: 4, pid: 2 },
    { id: 5, pid: 2 },
    { id: 6, pid: 3 },
];
// 要求编写一个函数 arr2tree(arr)，得到输出结果如下：

{
    "id": 0,
    "children": [
        {
            "id": 1,
            "children": [
                {
                    "id": 2,
                    "children": [
                        {
                            "id": 4
                        },
                        {
                            "id": 5
                        }
                    ]
                },
                {
                    "id": 3,
                    "children": [
                        {
                            "id": 6
                        }
                    ]
                }
            ]
        }
    ]
}
```

**实现**

```js
function arr2tree(arr) {
  let hash = {};
  const result = [];
  // 放到对象中
  for (let item of arr) {
    hash[item.id] = item;
  }

  for (let item of arr) {
    const parent = hash[item.pid];
    if (parent) {
      if (!parent.children) {
        parent.children = [];
      }
      delete item.pid; // 比结果多的字段删除
      parent.children.push(item); // 之所以能够实现，原因：使用了数组引用
    } else {
      delete item.pid; // 比结果多的字段删除
      result.push(item); // 只有第一次pid = 0的时候，树根节点才走这里
    }
  }
  hash = undefined; // 这里记得回收
  return result;
}

const res = arr2tree(arr);
console.log('res', JSON.stringify(res, null, 2));
```

### 地址数据处理

```js
// input = [
//   {id:1,city:'北京',pid:0},
//   {id:2,city:'河南',pid:0},
//   {id:3,city:'山西',pid:0},
//   {id:4,city:'洛阳',pid:2},
//   {id:5,city:'晋中',pid:3},
//   {id:6,city:'榆次',pid:5},
// ]
// result = [
//   {id:1,city:'北京',pid:0},
//   {id:2,city:'河南',pid:0,
//     children:[{id:4,city:'洛阳',pid:2}]
//   },
//   {id:3,city:'山西',pid:0,
//      children:[
//        {id:5,city:'晋中',pid:3,
//          children:[{id:6,city:'榆次',pid:5}]
//       }
//      ]
//   },
// ]
// 1. 转hash
// 2. 利用引用数据类型的特点，直接在原数据上操作
function toTree(arr) {
  arr.forEach(function (it) {
    delete it.children;
  });
  // 定义map/
  let map = {};
  // 这里可以重构数据类型，放回字段值
  arr.forEach(function (item) {
    map[item.id] = item;
  });

  // 定义返回集合
  let val = [];
  arr.forEach(function (item) {
    let parent = map[item.pid];
    if (parent) {
      // 有数据说明不是顶级节点，将数据放到该 children 子节点下
      (parent.children || (parent.children = [])).push(item);
    } else {
      // 没有数据说明是顶级节点放到val中
      val.push(item);
    }
  });
  return val;
}
```

### 如何找到数组中出现次数最多的字符串

```js
const findCountMax = (arr) => {
  let obj = {};
  // 转hash
  arr.forEach((item) => {
    if (obj[item]) {
      obj[item]++;
    } else {
      obj[item] = 1;
    }
  });
  // 遍历找最大值
  let result = { count: 0, str: '' };
  for (let item in obj) {
    if (obj[item] > result.count) {
      result.count = obj[item];
      result.str = item;
    }
  }
  return result.str;
};
```

### 数组扁平化

```js
// 没有深度控制的，不好
// 1. 对数组进行遍历，元素是数组的，递归遍历
const flattenArr = (arr) => {
  let result = [];
  // iife ，直接执行，不用下面再写调用了
  (function helper(arr) {
    arr.forEach((item) => {
      if (Array.isArray(item)) {
        helper(item);
      } else {
        result.push(item);
      }
    });
  })(arr);
  return result;
};
```

### 指定展开 N 层

```js
const flattenArrN = (arr, depth = 1) => {
  // 这里可以看作是闭包，将result进行缓存
  let result = [];
  // iife 立即执行，传入多个参数
  (function helper(arr, depth) {
    arr.forEach((item) => {
      // 限制在某一层级
      if (Array.isArray(item) && depth > 0) {
        // 这里每次depth都会递减
        helper(item, depth - 1);
      } else {
        result.push(item);
      }
    });
  })(arr, depth);

  return result;
};
```

## 对象

```js
const obj = {
  a: 1,
  b: [1, 2, { c: true }],
  c: { e: 2, f: 3 },
  g: null,
};

const result = {
  a: 1,
  'b[0]': 1,
  'b[1]': 2,
  'b[2].c': true,
  'c.e': 2,
  'c.f': 3,
  g: null,
};

// 实现
const isArray = (val) => toString.call(v) === '[object Array]';
const isObject = (val) => toString.call(v) === '[object Object]';
function ObjFlat(obj) {
  let result = {};
  (function helper(obj, prekey /*利用闭包进行传递 */) {
    if (!obj) return;

    Object.entries(obj)?.forEach(([key, value]) => {
      // 重点是合成key
      const keyStr = isArray(obj) ? `${prekey}[${key}]` : `${prekey}${key}`;

      if (isArray(value)) {
        helper(value, keyStr);
      } else if (isObject(value)) {
        helper(value, `${keyStr}.`);
      } else {
        // 直接给keyStr赋值
        result[keyStr] = value;
      }
    });
  })(obj, '');
  console.log('result', result);
  return result;
}
const obj = {
  a: 1,
  b: [1, 2, { c: true }],
  c: { e: 2, f: 3 },
  g: null,
};

ObjFlat(obj);
```

### 对象扁平化

## 正则

### 解析 URL 中所有的部分

```js
// 1.  拆分？后面的内容
// 2.  key
//     1.  无 value 转化成 true
//     2.  纯数字的转化成 数值
//     3.  value 是 数组/对象
function parseParam(url) {
  const paramsStr = /.+\?(.+)$/.exec(url)[1]; // ?之后部分截取
  const paramsArr = paramsStr.split('&'); // 拆分kv对
  let paramsObj = {};

  paramsArr.forEach((param) => {
    if (/=/.test(param)) {
      let [key, val] = param.split('=');

      val = decodeURIComponent(val); // 解码

      val = /^\d+$/.test(val) ? parseFloat(val) : val; // 字符串数值转化

      if (paramsObj.hasOwnProperty(key)) {
        paramsObj[key] = [].concat(paramsObj[key], val); // 这个没有直接push, 利用concat特性（数组concat,非数组push）
      } else {
        paramsObj[key] = val;
      }
    } else {
      // 有些没有=号
      paramsObj[param] = true;
    }
  });
  return paramsObj;
}
```

<!-- ## 使用 es5 实现 es6 的 let 关键字

<a href="https://blog.csdn.net/weixin_44242181/article/details/124340622" target="_blank" >es5 实现 es6+新特性</a> -->

### 中划线转大写

```js
var str = 'get-user-by-id';

var f = function (s) {
  return s.replace(/-\w/g, function (x) {
    return x.slice(1).toUpperCase();
  });
};
```

<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#:~:text=%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0-,%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%AF%E4%BB%A5%E6%8F%92%E5%85%A5%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F%E5%90%8D%EF%BC%9A,-%E5%8F%98%E9%87%8F%E5%90%8D" target="_blank" >替换字符串可以插入下面的特殊变量名：</a>

| 变量名    | 代表的值                                                                                        |
| --------- | ----------------------------------------------------------------------------------------------- |
| `$$`      | 插入一个 "$"。                                                                                  |
| `$&`      | 插入匹配的子串。                                                                                |
| $`        | 插入当前匹配的子串左边的内容。                                                                  |
| `$'`      | 插入当前匹配的子串右边的内容。                                                                  |
| `$n`      | 假如第一个参数是 RegExp 对象，并且 n 是个小于 100 的非负整数，那么插入第 n 个括号匹配的字符串。 |
| `$<Name>` | 这里*Name* 是一个分组名称。                                                                     |

1. `$n` : 提示：索引是从 1 开始。如果不存在第 n 个分组，那么将会把匹配到到内容替换为字面量。比如不存在第 3 个分组，就会用“$3”替换匹配到的内容。
2. `$<Name>`: 如果在正则表达式中并不存在分组（或者没有匹配），这个变量将被处理为空字符串。只有在支持命名分组捕获的浏览器中才能使用。

### 金额千分

```js
function parseToMoney(num) {
  num = parseFloat(num).toFixed(3);

  let [integer, decimal] = String.prototype.split.call(num, '.');

  integer = integer.replace(/\d(?=(\d{3})+$)/g, '$&,');
  // 从右到左“三个数值一组” ?= 尽可能多的去匹配

  return `${integer}.${decimal}`;
}

console.log(parseToMoney(10000000.0));

// $& 与regexp相匹配的子串。 // https://q.cnblogs.com/q/63769/
```

<a href="https://regexper.com/#%2F%5Cd%28%3F%3D%28%5Cd%7B3%7D%29%2B%24%29%2Fg" target="_blank" >/\d(?=(\d{3})+$)/g</a>

### Intl.NumberFormat

```js
// example1
const options = {
  style: 'currency',
  currency: 'CNY',
};
console.log((999999.1212).toLocaleString('zh-CN', options)); // ¥999,999.12

// example2
var val = Intl.NumberFormat('zh-CN', { maximumSignificantDigits: 18 }).format(999999.1212);

console.log('val', val); // val 999,999.1212
```

## 原理实现

### new

<a href="/#/post/2022-06-16interview#:~:text=new%20%E5%92%8C%20Object.create%20%E9%83%BD%E6%98%AF%E5%88%9B%E9%80%A0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%84%8F%E6%80%9D%EF%BC%8C%E4%BA%8C%E8%80%85%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F" target="_blank" >见</a>

```js
// @link: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new
// 1. 创建一个空的简单 JavaScript 对象（即 {}）；
// 2. 为步骤 1 新创建的对象, 添加属性 __proto__，将该属性链接至构造函数的原型对象；
// 3. 将步骤 1 新创建的对象, 作为 this 的上下文；
// 4. 如果该函数没有返回对象，则返回 this。
function myNew() {
  // 1. 创建一个空的简单 JavaScript 对象（即 {}）；
  let obj = {};
  // 2. 为步骤 1 新创建的对象, 添加属性 __proto__，将该属性链接至构造函数的原型对象；
  let func = [].shift.call(arguments); //出列，获取第一个参数
  obj.__proto__ = func.prototype; //proto指向原型
  // 3. 将步骤 1 新创建的对象, 作为 this 的上下文；
  const result = func.apply(obj, arguments); //让obj执行func函数
  // 4. 如果该函数没有返回对象，则返回 this。
  return result intanceof Object ? result :  obj;
}
```

### Object.create

```js
Object.myCreate = function (proto, propertyObj = undefined) {
  // propertyObj 不可以时null，因为 Object.Create规定第二参数不可以时undefined和 null
  if (propertyObj === null) throw "TypeError";
  // 23模式-原型模式，使用寄生继承，用现有对象作为新创建对象的原型
  let F = function () {};
  F.prototype = proto;
  let obj = new F();
  // 对象的自有可枚举属性，将为新创建的对象添加指定的属性值和对应的属性描述符
  if (propertyObj !== undefined) {
    Object.defineProperties(obj, propertyObj);
  }
  // null创建无原型的对象
  if (proto === null) {
    obj.__proto__ = null;
  }
  // 一个新对象，带着指定的原型对象及其属性
  return obj;
};



// 示例
// 第二个参数为null时，抛出TypeError
// const throwErr = Object.myCreate({a: 'aa'}, null)  // Uncaught TypeError
// 构建一个以
const obj1 = Object.myCreate({a: 'aa'})
console.log(obj1)  // {}, obj1的构造函数的原型对象是{a: 'aa'}
const obj2 = Object.myCreate({a: 'aa'}, {
  b: {
    value: 'bb',
    enumerable: true
  }
})
console.log(obj2)  // {b: 'bb'}, obj2的构造函数的原型对象是{a: 'aa'}

作者：李永宁
链接：https://juejin.cn/post/6844904174983872519
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### instanceof

instanceof 运算符用于检测`构造函数的 prototype 属性`是否出现在某个`实例对象的原型链`上

```js
function instance_of(L, R) {
  var O = R.prototype; // 取R的显示原型
  L = L.__proto__; // 取L的隐式原型

  while (true) {
    // 死循环，结束条件：要么找到，要么没找到
    if (L === null) return false;

    // 这里重点：当O严格等于L时，返回true
    if (O === L) return true;

    L = L.__proto__;
  }
}
```

### JSONP

本质是一个 hack,利用`<script>`标签不受同源侧露限制的特性进行跨域操作

<a href="https://blog.csdn.net/weixin_42371354/article/details/104651961" target="_blank" >参考链接</a>
<a href="https://blog.csdn.net/qq_38800316/article/details/120440865" target="_blank" >jsonp 函数封装</a>

```js
// 1. 生成个函数名
// 2. 整理参数，生成请求url
// 3. 动态创建script标签，并挂载
// 4. 加载完成后移除script标签
function jsonP({ url, params, success }) {
  // 在参数里制定callback的名字
  params = params || {};
  // 预留callback
  const funcName = 'func' + Math.random().toString().replace('.', '');
  // 这样依赖，服务器端一个req.query.callback就可以获取到动态的函数名
  params.callback = funcName;
  window[funcName] = success;

  // 拼接参数字符串
  const paramKeys = Object.keys(params);
  const paramString = paramKeys.map((key) => `${key}=${params[key]}`).join('&');

  // 插入dom元素
  const script = document.createElement('script');

  script.setAttribute('src', `${url}?${paramString}`);

  document.body.appendChild(script);
  // 监听script标签的onload事件，当script标签执行后将其删除，避免代码结构的冗余
  script.onload = function () {
    // 从body的删除掉添加的script标签
    document.body.removeChild(script);
    delete window[funcName];
  };
}

// 使用

jsonP({
  url: 'https://example.com/ajax/jsonp/suggestion',
  params: {
    key: 'test',
  },
  success(result) {
    console.log(result.data);
  },
});
```

### 实现 event bus

作用：

**1. 简化了应用程序内各个组件之间进行通信的复杂度，尤其是碎片之间进行通信的问题，可以避免由于使用广播通信而带来的诸多不便**

```js
// 1. 监听收集（on/once）
// 2. 触发监听(emit)
// 3. 解除监听(off)
// 4. 清空监听(clear)
class EventBus {
  constructor() {
    this.events = {};
  }
  // 监听，给对象添加方法
  on(name, callback) {
    const { events } = this;
    if (!events[name]) {
      events[name] = [];
    }
    events[name].push(callback);
  }
  // 取出来执行
  emit(name, ...args) {
    const handlers = this.events[name];
    handlers?.forEach((fn) => {
      fn.apply(this, args);
    });
  }
  // 解除
  off(name, callback) {
    const { events } = this;
    if (!events[name]) return;
    events[name] = events[name].filter((fn) => fn !== callback); // 引用，指向对象，直接改kv键值对
  }
  //  用完立马、解除
  once(name, callback) {
    const handler = function () {
      callback.apply(this, arguments); // 普通函数参数
      this.off(name, handler);
    };
    this.on(name, handler);
  }
  // 事件清空
  clear() {
    this.events = {};
  }
}
```

### 实现发布订阅

```js
class Observer {
  caches = {}; // 事件中心

  // eventName事件名-独一无二, fn订阅后执行的自定义行为
  on(eventName, fn) {
    this.caches[eventName] = this.caches[eventName] || [];
    this.caches[eventName].push(fn);
  }

  // 发布 => 将订阅的事件进行统一执行
  emit(eventName, data) {
    if (this.caches[eventName]) {
      this.caches[eventName].forEach((fn) => fn(data));
    }
  }
  // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息
  off(eventName, fn) {
    if (this.caches[eventName]) {
      const newCaches = fn ? this.caches[eventName].filter((e) => e !== fn) : [];
      this.caches[eventName] = newCaches;
    }
  }
}
```

### Object.defineProperties 实现原理

`Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象`<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties#polyfill" target="_blank" >见</a>

<a href="/#/post/2023-03-09defineProperty" target="_blank" >/#/post/2023-03-09defineProperty</a>

```js
function defineProperties(obj, properties) {
  function convertToDescriptor(desc) {
    // 是否有这个属性
    function hasProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    // 是否可以被调用
    function isCallable(v) {
      // NB: modify as necessary if other values than functions are callable.
      return typeof v === 'function';
    }
    // 基本数据类型
    if (typeof desc !== 'object' || desc === null) throw new TypeError('bad desc');

    var d = {};

    /*数据描述：可枚举、可配置、值、可改写*/
    if (hasProperty(desc, 'enumerable')) d.enumerable = !!desc.enumerable;
    if (hasProperty(desc, 'configurable')) d.configurable = !!desc.configurable;
    if (hasProperty(desc, 'value')) d.value = desc.value;
    if (hasProperty(desc, 'writable')) d.writable = !!desc.writable;

    /*存储描述 */
    function storeDesc(desc, key) {
      var g = desc[key];
      if (!isCallable(g) && typeof g !== 'undefined') throw new TypeError(`bad ${key}`);
      d[key] = g;
    }
    // 不再进一步封装
    if (hasProperty(desc, 'get')) storeDesc(desc, 'get');
    if (hasProperty(desc, 'set')) storeDesc(desc, 'set');

    // 描述符冲突
    // @link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#:~:text=%E4%B8%BA%20undefined%E3%80%82-,%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%AF%E6%8B%A5%E6%9C%89%E7%9A%84%E9%94%AE%E5%80%BC,-configurable
    // 1. 如果一个描述符不具有 value、writable、get 和 set 中的任意一个键，那么它将被认为是一个数据描述符。
    // 2. 如果一个描述符同时拥有 value 或 writable 和 get 或 set 键，则会产生一个异常。
    if (('get' in d || 'set' in d) && ('value' in d || 'writable' in d)) throw new TypeError('identity-confused descriptor');

    return d;
  }
  // 被扩展的必须是对象
  // 会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象
  if (typeof obj !== 'object' || obj === null) throw new TypeError('bad obj');
  // 转化成对象, Object是一个构造函数
  properties = Object(properties);
  // 遍历key
  var keys = Object.keys(properties);
  var descs = [];

  for (var i = 0; i < keys.length; i++) {
    Object.defineProperty(obj, keys[i], convertToDescriptor(properties[keys[i]]));
  }

  // 返回原对象
  return obj;
}
```

## 柯里化

### 柯里化是什么

<a href="https://article.itxueyuan.com/46m5K2" target="_blank" >见</a>
在计算机科学中，柯里化（Currying）`是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术`。这个技术以逻辑学家 Haskell Curry 命名的。

1. 柯里化突出一种重要思想：`降低适用范围`，`提高适用性`
2. 柯里化的三个作用和特点：`参数复用`、`提前返回`、`延迟执行`
3. 柯里化是闭包的一个典型应用:
   1. `利用闭包形成了一个保存在内存中的作用域，把接收到的部分参数保存在这个作用域中，等待后续使用`。
   2. 并且返回一个新函数接收剩余参数

<a href="https://juejin.cn/post/6844903814139478030" target="_blank" >函数柯里化和偏函数应用</a>

- 柯里化和偏函数都是用于将多个参数函数，转化为接受更少参数函数的方法。传入部分参数后，处于中间状态的函数可以作为固定值进行复用。但是其中不同之处在于：

- `柯里化`是将函数转化为多个嵌套的一元函数，也就是每个函数只接受一个参数。
- `偏函数`可以接受不只一个参数，它被固定了部分参数作为预设，并可以接受剩余的参数

作者：LanceT
链接：https://juejin.cn/post/6844903814139478030
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 实现柯里化

```js
function sum(a, b, c, d, e) {
  return a + b + c + d + e;
}

let resFunc = curry(sum);
console.log(resFunc(1, 3, 4)(1)(23));
// 方式2，利用bind的数据积累特性
function curry(fn, ...args) {
  if (args.length >= fn.length) {
    return fn(...args);
  } else {
    // bind绑定，不执行，
    // bind返回一个函数
    // bind会将之前的参数和之后的参数进行合并
    // 这里涉及bind和apply的实现原理
    return curry.bind(null, fn, ...args);
  }
  // return fn.length == args.length ? fn(...args) : curry.bind(null, fn, ...args);
}
```

### 洋葱模型

<a href="https://github.com/841660202/redux/blob/2edd0363271af46e327e118f3d92e78e258bf0cd/src/compose.ts#L46" target="_blank" >redux compose 源码</a>

```ts
// 1. 无函数
// 2. 1个函数
// 3. 多个函数
export default function compose(...funcs: Function[]) {
  if (funcs.length === 0) {
    // infer the argument type so it is usable in inference down the line
    return <T>(arg: T) => arg;
  }

  if (funcs.length === 1) {
    return funcs[0];
  }
  // prettier-ignore
  return funcs.reduce((a, b) => (...args: any) => a(b(...args)));
}
```

## 数据代理/劫持

<a href="https://www.freesion.com/article/47611264830/" target="_blank" >数据劫持|数据代理</a>

<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" >MDN</a>

### proxy

<a href="https://blog.csdn.net/xgangzai/article/details/128489924" target="_blank" >Proxy & Reflect </a>

```js
// Proxy
//  数据对象
let obj = {
  name: 'Eason',
  age: 30,
};
// 处理
let handler = {
  get(target, key, receiver) {
    console.log('get', key);
    return Reflect.get(target, key, receiver);
  },
  set(target, key, value, receiver) {
    console.log('set', key, value);
    return Reflect.set(target, key, value, receiver);
  },
};

let proxy = new Proxy({ ...obj }, handler);

proxy.name = 'Zoe'; // set name Zoe
proxy.age = 18; // set age 18

// defineProperty

let arr = [1, 2, 3];
let obj = {};
Object.defineProperty(obj, 'arr', {
  get() {
    console.log('get arr');
    return arr;
  },
  set(newVal) {
    console.log('set', newVal);
    arr = newVal;
  },
});
obj.arr.push(4); // 只会打印 get arr, 不会打印 set
obj.arr = [1, 2, 3, 4]; // 这个能正常 set
```

### defineProperty

```js
// defineProperty

let arr = [1, 2, 3];
let obj = {};
Object.defineProperty(obj, 'arr', {
  get() {
    console.log('get arr');
    return arr;
  },
  set(newVal) {
    console.log('set', newVal);
    arr = newVal;
  },
});
obj.arr.push(4); // 只会打印 get arr, 不会打印 set
obj.arr = [1, 2, 3, 4]; // 这个能正常 set
```

### (a === 1 && a === 2 && a === 3) === true

<a href="https://blog.csdn.net/RedaTao/article/details/107170267" target="_blank" >a == 1 && a == 2 && a == 3</a>

什么样的 a 可以满足 (a === 1 && a === 2 && a === 3) === true 呢？(注意是 3 个 =，也就是严格相等)???

```js
let i = 1;
Object.defineProperty(window, 'a', {
  get: function () {
    return i++;
  },
});

console.log(a == 1 && a == 2 && a == 3);
```

## 链表

**什么是链表**

数据的一种存储结构，一个链表包含若干个节点，每个节点至少包含一个数据域和指针域

<a href="https://wenku.baidu.com/view/33d6ed103a68011ca300a6c30c2259010302f35b.html" target="_blank" >百度文库(收费了，只能看部分)、参考链接</a>

<a href="https://blog.csdn.net/m0_47109503/article/details/117566907" target="_blank" >参考链接</a>

### 单向 vs 双向

单向链表：只有一个指向下一个节点的指针。

1. 优点：单向链表增加删除节点简单。遍历时候不会死循环；
2. 缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。

适用于节点的增加删除。

双向链表：有两个指针，一个指向前一个节点，一个后一个节点。

1. 优点：可以找到前驱和后继，可进可退；
2. 缺点：增加删除节点复杂，需要多分配一个指针存储空间。

适用于需要双向查找节点值的情况

<a href="https://blog.csdn.net/qq_36553031/article/details/82885804" target="_blank" >单向链表和双向链表的优缺点及使用场景</a>

### 单链表

1. 链表的节点为「数据 data、指针 next」的数据接口， 节点通过指针串联起来的数据结构：拥有 节点的增、删、改功能，还可以进行遍历
   1. 链表的最后一个节点的 next=null
   2.

```js
// 在创建链表时，需要创建两个类：指针类和节点类
class Node {
  constructor(data) {
    this.data = data; // 节点的数据域/数据成员
    this.next = null; // 节点的指针域/指针成员
  }
}
// 定义一个单向链表类
class singleLinked {
  constructor() {
    this.size = 0; // 记录单链表长度或节点个数
    this.head = new Node('head'); // 记录链表的头指针：主要作用记录链表的起始地址
    this.currentNode = '';
  }
  // 获取链表的长度
  getLength() {
    return this.size;
  }
  // 判断链表是否为空
  isEmpty() {
    return this.size === 0;
  }
  // 遍历链表：不重复访问链表中的每个节点
  displayList() {
    var list = '';
    var currentNode = this.head; // 指向链表的头指针
    while (currentNode) {
      // 如果当前节点不为空，则表明当前节点中存在数据
      list += currentNode.data;
      // 同时让当前节点的指针指向下一个节点
      currentNode = currentNode.next;

      if (currentNode) {
        // 如果当前节点的下一个节点不为空
        list += '->'; // 拼接后看起来像一个链表
      }
    }
    console.log(list);
  }

  // 获取链表的最后一个节点
  findLast() {
    var currentNode = this.head;
    while (currentNode.next) {
      currentNode = currentNode.next;
    }
    return currentNode;
  }

  // 采用尾插法在链表尾部添加元素，即创建一个链表
  appendNode(element) {
    var currentNode = this.findLast(); // 找到链表的最后一个节点
    var newNode = new Node(element); // 创建一个新节点
    currentNode.next = newNode; // 把新的节点放在链表里去（放在最后一个的后面）
    // newNode.next = null; // 因为新节点已经是链表最后一个节点
    this.size++; // 因为新插入一个节点，让链表的长度+1
  }
  // 删除一个节点
  deleteNode(element) {
    var currentNode = this.head;
    while (currentNode.next.data !== element) {
      currentNode = currentNode.next;
    }
    // 将链的节点与另一个节点连上
    currentNode.next = currentNode.next.next;
    this.size--;
  }
}

// 上述链表代码的测试
// 最好使用循环，往里面加数据
var slist = new singleLinked();

var arr = [1001, 1234, 1006, 7788, 5512, 6129];
for (var i = 0; i < arr.length; i++) {
  slist.appendNode(arr[i]);
}
slist.displayList();
slist.deleteNode(1001);
slist.displayList();
```

### 双向链表《不是环》

<a href="https://blog.csdn.net/dingshao1114/article/details/105340579" target="_blank" >js 数据结构之双向链表 doublyLinkedList</a>

<img src="https://img-blog.csdnimg.cn/20200406112533896.png#pic_center" />

```js
/**
 * 双向链表节点
 * 包含三个值: 当前节点的值和分别指向前后节点的指针
 */
class Node {
  constructor(element) {
    this.element = element;
    this.next = null;
    this.prev = null;
  }
}

/** 双向链表 */
class DoublyLinkedList {
  constructor() {
    this.head = null;
  }

  /** 在链表末尾添加一个元素 */
  add(element) {
    // 链表是否已有节点
    const node = new Node(element);
    // 没有节点
    if (this.head === null) {
      this.head = node;
      return;
    }
    // 有节点
    let current = this.head;
    while (current.next) {
      current = current.next;
    }
    current.next = node;
    node.prev = current;
  }

  /** 删除 */
  remove(element) {
    // 链表无数据
    if (this.head === null) {
      return false;
    }
    let current = this.head;
    // 链表有数据
    if (current.element === element) {
      // 有2个
      if (this.head.next) {
        this.head = this.head.next;
        this.head.prev = null;
      // 只有一个
      } else {
        this.head = null;
      }
      return true;
    }
    let prev;
    while (current !== null && current.element !== element) {
      prev = current;
      current = current.next;
    }
    if (current) {
      prev.next = current.next || null;
      // 与之前的节点建立pre链接
      if (current.next) {
        current.next.prev = prev;
      }
      return true;
    }
    return false;
  }

  /** 反向遍历 */
  reverse() {
    let current = this.head;
    let prev = null;
    let tail = null;
    // step1: 调序重排
    while (current !== null) {
      prev = current.prev;
      // pre 指向后面，next指向前面
      current.prev = current.next;
      current.next = prev;

      tail = current;
      current = current.prev;
    }
    this.head = tail;
    // step2: 正序遍历
    current = this.head;
    while (current !== null) {
      yield current.element;
      current = current.next;
    }
  }
}

// 示例
const list = new DoublyLinkedList();
list.add("1");
list.add("2");
list.add("5");
list.add("3");

list.remove("5");

const reverseList = list.reverse();

console.log(reverseList.next());
console.log(reverseList.next());
console.log(reverseList.next());
```

### 链表反转

```js
function reverseList(head) {
  // 初始化prev/cur指针
  let prev = null; // pre指针（新链表的头指针）
  let cur = head; // cur指针
  // 开始遍历链表
  while (cur) {
    let next = cur.next; // 暂存，之后用于cur指针移动
    cur.next = prev; // 建立新的链表关系
    prev = cur; // pre 指针移动
    cur = next; // cur 指针移动
  }
  return prev;
}
```

### 链表有环

```js
// 1. 终止条件：
//    有环快慢指针相遇
//    无环遍历结束的时候
function hasCycle(head) {
  let fast = head;
  let slow = head;
  while (fast && fast.next) {
    fast = fast.next.next;
    slow = slow.next;
    // 有环终止的条件
    if (fast === slow) return true;
  }
  return false;
}
```

### 链表中点

链表有中点，则链表没有环,快指针式慢指针的两倍速度，快指针到链表尾部时候，慢指针刚好到临近中间位置

1. 链表`1->2->3->4->5->6->null`, fast === null 结束时, 已完成情况：fast:`1,3,5,null`, slow: `1,2,3`
2. 链表`1->2->3->4->5->6->7->null`, fast.next === null 结束时,已完成情况： fast: `1,3,5,7`, slow: `1,2,3`, 这里慢指针并没有到达中间点，还差一步

```js
function middleNode(head) {
  // body
  let fast = head;
  let slow = head;

  while (fast && fast.next) {
    fast = fast.next.next;
    slow = slow.next;
  }
  // 看是fast结束的还是fast.next结束的
  // 处理链表节点为奇数的情况
  if (fast) {
    // 也就是fast.next === null的情况
    slow = slow.next;
  }
  return slow;
}
```

### 链表中环的入口节点

1. 理解：快慢指针相遇点
2. 理解：什么是环的入口

<img src="http://t-blog-images.aijs.top/img/202303071103119.webp" />

<a href="https://zhuanlan.zhihu.com/p/103626709" target="_blank" >链表中环的入口节点</a>

```js
// 阶段1: 快指针走两步，慢指针走一步，找到相遇点
// 阶段2: 快指针从头一步一步走，慢指针从相遇点一步一步走（为什么成立：因为方程式有解）
function detectCycle(head) {
  let fast = head;
  let slow = head;
  while (fast && fast.next) {
    fast = fast.next.next;
    slow = slow.next;
    // prettier-ignore
    if (fast == slow) { // 相遇点
      fast = head; // 快指针从头走
      while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
      }
      return slow;
    }
  }
  return null;
}
```

### 判断链表是否相交

<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/" target="_blank" > 相交链表（双指针，清晰图解）</a>

<img src="https://pic.leetcode-cn.com/1615224578-EBRtwv-Picture1.png" />

```js
function intersectionNode(headA, headB) {
  let [curA, curB] = [headA, headB];
  while (curA !== curB) {
    curA = curA.next === null ? headB : curA.next;
    curB = curB.next === null ? headA : curB.next;
  }
  return curA;
}

// 测试----------------------------------

class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class SingleLink {
  constructor() {
    this.size = 0;
    this.head = new Node('head');
  }
  // 找到链表的最后一个节点
  findLastNode() {
    let curNode = this.head;
    while (curNode.next) {
      curNode = curNode.next;
    }
    return curNode;
  }
  // 追加节点
  appendNode(node) {
    const lastNode = this.findLastNode();
    lastNode.next = node;
    node.next = null; // 这个必须加，否则有循环
    this.size++;
  }
}

var a = [1, 11];

var b = [0, 2, 3];

var common = ['a', 'b'];
// 链表A
const linka = new SingleLink();
for (let i = 0; i < a.length; i++) {
  linka.appendNode(new Node(a[i]));
}

// 链表B
const linkb = new SingleLink();
for (let i = 0; i < b.length; i++) {
  linkb.appendNode(new Node(b[i]));
}

// 共节点链表
for (let i = 0; i < common.length; i++) {
  const cNode = new Node(common[i]);
  linka.appendNode(cNode);
  linkb.appendNode(cNode);
}

console.log('linka', linka);

var cNodeLink = intersectionNode(linka.head, linkb.head);
console.log('cNodeLink', JSON.stringify(cNodeLink, null, 2));

// cNodeLink {
//   "data": "a",
//   "next": {
//     "data": "b",
//     "next": null
//   }
// }
```

## 排序

### 冒泡排序

<img src="https://img-blog.csdnimg.cn/img_convert/afb80e39ce7684d6330fdc66b0873abd.gif" style={{width:300}} />

总图了解到：冒泡路径越来越短: n n-1 n-2 ... 2 1

```js
// 解构方式进行赋值
const swap = (arr, i, j) => ([arr[i], arr[j]] = [arr[j], arr[i]]);

// 外层遍历负责次数 i<len-1
// 内层遍历处理数据对比 j=0 ,j<len-i-1
function BubbleSort(arr) {
  let len = arr.length;
  if (len < 2) return arr; // 没有排序价值
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {
      // 是否需要冒泡，这里的冒泡是冒泡到尾部
      if (arr[j] > arr[j + 1]) swap(arr, j, j + 1);
    }
  }
  return arr;
}
```

### 选择排序

<img src="https://img-blog.csdnimg.cn/img_convert/76339a259488423b03370e381ca5edb0.gif" style={{width:300}}/>

总图了解到：冒泡路径越来越短: n n-1 n-2 ... 2 1

```js
const swap = (arr, i, j) => ([arr[i], arr[j]] = [arr[j], arr[i]]);

// 同向比较
const SelectSort = (arr) => {
  let len = arr.length;
  let i /*一重遍历 */, j /*二重遍历 */, minIndex /*最小元素的下标 */;
  for (let i = 0; i < len; i++) {
    // 每次找最小的进行交换，直至结束
    minIndex = i;
    for (let j = i + 1; j < len; j++) {
      //每次找最小的
      if (arr[j] < arr[minIndex]) minIndex = j;
    }
    swap(arr, i, minIndex);
  }
  return arr;
};
```

### 插入排序

<img src="https://img-blog.csdnimg.cn/img_convert/c894e22dcc48b03559e3087627e3dbb8.gif" style={{width:300}}/>

被遍历元素与前面的元素逐个相比较，前面的元素挪位给它

```js
// sential = arr[i] 外层
// 内存循环条件 j=i-1
function insertSort(arr) {
  if (arr.length <= 0) return arr;
  for (let i = 1; i < arr.length; i++) {
    let temp = arr[i];
    let j = i - 1; // 取前一个位置元素
    // prettier-ignore
    for (; j >= 0 && arr[j] > temp; j--) {   // 挪位置
      arr[j + 1] = arr[j];
    }
    // 将元素放置到这个位置
    arr[j + 1] = temp;
  }

  return result;
}
```

### 归并排序

<img src="https://img-blog.csdnimg.cn/956f63eccd75480791c85edd8ce91658.gif" style={{width:300}}/>

```js
const arr = [2, 44, 1, 0, -22, 56, -78];
// 分-合过程，分：递 、合：归
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  const middle = Math.floor(arr.length / 2);
  const left = arr.slice(0, middle);
  const right = arr.slice(middle);
  // 递
  return merge(mergeSort(left), mergeSort(right));
  // 归
  // 辅助函数，用于将两个数组合并为一个有序数组，并返回
  function merge(left, right) {
    const result = [];
    while (left.length && right.length) {
      // 放入较小的元素，并从头部移出
      result.push(left[0] <= right[0] ? left.shift() : right.shift());
    }
    result.push(...left, ...right); // 放入剩余元素
    return result;
  }
}

console.log(mergeSort(arr));
```

### 希尔排序

<img src="http://t-blog-images.aijs.top/img/1940317-acc6c6f16b096794.gif" />

### 快速排序

<img src="https://img-blog.csdnimg.cn/img_convert/4ad3b539bee9bfe9a6acdba476ceed78.gif" style={{width:300}} />

<img src="http://t-blog-images.aijs.top/img/20220704153839.webp" />

找基点，小于的排左侧，大于的排右侧

```js
/*
快排是冒泡的一种改进，基于分治思想
*/
const arr2 = [2, 44, 1, 0, -22, 56, -78];

function quickSort(arr) {
  if (arr.length <= 1) return arr;

  const pivot = arr.pop(); // 使用最后一个元素当作基准数
  // prettier-ignore
  const left = [], right = [];

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) left.push(arr[i]); // 小于基准数则放到left
    else right.push(arr[i]); // 大于基准数则放到right
  }
  // 合并left的快排结果，基准数和右侧的快排结果
  return quickSort(left).concat(pivot, quickSort(right));
}

console.log(quickSort(arr2));
```

## LRU 算法

`LRU 定义`： 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择内存中最近最久未使用的页面予以淘汰。

`使用场景`：正如定义所说，如果我们想要实现缓存机制 -- 满足最近最少使用淘汰原则，我们就可以使用 LRU 算法缓存机制。如：vue 中 keep-alive 中就用到了此算法。

`实现思路`： -- 维护一个数组，提供 get 和 put 两个方法，并且限制数组元素数量（及缓存数量）

`实现方法`：

    1. get 可以标记某个元素是最新使用的，提升到第一项
    2. put 可以加入一个 key-value 元素，但是需要判断是否已存在，是否超出限额

```js
// 时间复杂度 O(1)，因为 Map 既能保持键值对，还能记住插入顺序。
var LRUCache = function (capacity) {
  this.cache = new Map();
  this.capacity = capacity;
};

LRUCache.prototype.get = function (key) {
  if (this.cache.has(key)) {
    // 存在即更新
    let temp = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, temp);
    return temp;
  }
  return -1;
};

LRUCache.prototype.put = function (key, value) {
  // 存在即更新（删除后加入）,这种情况肯定不会溢出
  if (this.cache.has(key)) {
    this.cache.delete(key);
    // 不存在即加入
    // 缓存超过最大值，则移除最近没有使用的
  } else if (this.cache.size >= this.capacity) {
    // new Map().keys() 返回一个新的 Iterator 对象
    this.cache.delete(this.cache.keys().next().value);
  }
  this.cache.set(key, value);
};

// var map = new Map()
// map.set(1,1)
// Map(1) {1 => 1}
// map.set(2,2)
// Map(2) {1 => 1, 2 => 2}
// map.set(3,3)
// Map(3) {1 => 1, 2 => 2, 3 => 3}

// map.keys().next()
// {value: 1, done: false}

// 类实现

class LRU {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }
  // 获取
  get(key) {
    if (this.cache.has(key)) {
      // 删除后新增
      const temp = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, temp);
      return temp;
    }
    return -1;
  }
  // 设置
  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }else (this.cache.size>=this.capacity){
      this.cache.delete(this.cache.keys().next().value)
    }

    this.cache.set(key, value);
  }
}
```

## leecode

### 红包算法

### 括号匹配

```js
// 左匹配进栈
// 右匹配出栈
// 进栈==出栈数量
function isValid(s) {
  let stack = new Stack();
  // 遍历 字符串
  for (let c of s) {
    // 遇到左括号，将与其匹配的右括号入栈处理

    if (c === '(') {
      stack.push(')');
    } else if (c === '[') {
      stack.push(']');
    } else if (c === '{') {
      stack.push('}');
      // 遇到右括号
      // 1. 判断栈内是否有括号，如果没有，那说明此时匹配不了
      // 2. 满足①的情况下，判断此时字符是否和栈顶元素匹配
    } else if (stack.isEmpty() || stack.pop() !== c) {
      return false;
    }
  }
  // 最后再验证一下，栈是否为空，如果不为空，说明还有未匹配的括号
  return stack.isEmpty();
}
// 原理：数组的 push 和 pop
class Stack {
  constructor() {
    this.items = [];
  }
  // 进栈
  push(element) {
    this.items.push(element);
  }
  // 出栈
  pop() {
    return this.items.pop();
  }
  // 是否为空
  isEmpty() {
    return this.items.length === 0;
  }
}
```

### 螺旋矩阵

### 大数相加

<a href="https://blog.csdn.net/qq_39816673/article/details/88667505" target="_blank" >JS 大数相加</a>

```js
function add(str1, str2) {
  str1 = str1.split(''); // 转化成数组
  str2 = str2.split(''); // 转化成数组

  let result = ''; // 结果
  let flag = 0; // 满10进1标记

  while (str1.length || str2.length || flag) {
    // 计算完
    const val = flag + ~~str1.pop() + ~~str2.pop(); // ~~undefined = 0, true + 0 =1, false + 0 = 0
    // 结果
    result = (val % 10) + result;
    // 是否进位
    flag = val > 9 ? val % 10 : 0;
  }
  return result.replace(/^0+/, ''); // 首部有0去除
}

console.log(add('00125', '0131231231232132136'));
```

### 找出出现次数最多的英语单词

```js
var paragraph = 'Bob hit a ball, the hit BALL flew far after it was hit.';

function findMaxWord(paragraph) {
  // prettier-ignore
  var p = paragraph.replace(/[\W\s]/g, " ").toLowerCase().split(" ");
  // console.log("p", p);
  // ['bob', 'hit', 'a', 'ball', '', 'the', 'hit', 'ball', 'flew', 'far', 'after', 'it', 'was', 'hit', '']
  const obj = {};

  for (const word of p) {
    if (!word) continue;
    if (obj[word]) {
      obj[word]++;
    } else {
      obj[word] = 1;
    }
  }

  let max = 0;
  let word = '';
  for (const k in obj) {
    if (obj[k] > max) {
      max = obj[k];
      word = k;
    }
  }

  return {
    count: max,
    word,
  };
}

const res = findMaxWord(paragraph);
console.log(res);
```

### 节点倒序（将 ul.id=list，将 ul 节点下的 10000 个 li 节点倒序。考虑性能。）【待处理】

### 实现一个函数计算 "1+12-31+100-93"【待处理】

```js
function calc(str) {
  return eval(str);
}

function calcStr(str) {
  var newStr = a.replace(/-\d+/g, (x) => {
    return '+' + x;
  });
  let result = newStr.split('+').reduce((pre, crt) => pre + parseFloat(crt), 0);
  console.log('eval(a)', eval(str));
  console.log('result', result);
  return result;
}
var a = '1+12-31+100-93';
// var a = "1+12+(-31)+100+(-93)";

calcStr(a);
```

### 判断链表是否有环

- 快慢指针

  <a href="https://www.zhihu.com/question/23208893" target="_blank" >为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？</a>

```js
class Solution {
  ...
  hasCycle() {
    let fast = this.head; // 每次走两步
    let slow = this.head; // 每次走一步
    while (fast && fast.next) {
      fast = fast.next.next
      // 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6
      //               fast
      //               slow
      slow = slow.next
      // 如果最终两人相遇了，则有环
      if(fast === slow){
        return true
      }
    }
    // 如果结束了，说明无环
    return false
  }
}
```

### 爬楼梯【动态规划】

<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408" target="_blank" >百度百科-动态规划</a>

**多阶段决策问题**

1. 如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题
2. 各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果

**动态规划问题中的术语**

`阶段`：

    1. 把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．
    2. 描述阶段的变量称为阶段变量。
    3. 在多数情况下，阶段变量是离散的，用 k 表示。此外，也有阶段变量是连续的情形。
    4. 如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的

`状态`：

    1. 状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。
    2. 在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点

`决策`：

    1. 一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。
    2. 在最优控制中，也称为控制。
    3. 在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。
    4. 描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史

`最优化原理`：作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略”
`最优性原理`：实际上是要求问题的最优策略的子策略也是最优

```js
// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。

// 在循环的过程中，不断替换其中的值， 最后的结果，就是所有的方法数
function minCost(cost) {
  // 定义一个变量
  let len = cost.length;
  // 定义两个变量
  let dp = [cost[0], cost[1]];

  for (let i = 2; i < len; i++) {
    // 0/1 下标数组， 偶数 & 1 = 0， 奇数 & 1 =1
    dp[i & 1] = Math.min(dp[0], dp[1]) + cost[i];
    console.log(`dp[${i & 1}]`, i, dp[i & 1], dp);
  }

  // 循环结束后
  return Math.min(dp[0], dp[1]);
}

var a = minCost([1, 2, 3, 4, 5]);

console.log('a', a);

// 作者：前端小魔女
// 链接：https://juejin.cn/post/7206912311562174523
// 来源：稀土掘金
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 什么是时间复杂度&计算

### 什么是空间复杂度&计算

### 删除单向链表中的某个节点

```js
// 在创建链表时，需要创建两个类：指针类和节点类
class Node {
  constructor(data) {
    this.data = data; // 节点的数据域/数据成员
    this.next = null; // 节点的指针域/指针成员
  }
}
// 定义一个单向链表类
class singleLinked {
  constructor() {
    this.size = 0; // 记录单链表长度或节点个数
    this.head = new Node('head'); // 记录链表的头指针：主要作用记录链表的起始地址
    this.currentNode = '';
  }
  // 删除一个节点
  deleteNode(element) {
    var currentNode = this.head;
    while (currentNode.next.data !== element) {
      currentNode = currentNode.next;
    }
    // 将链的节点与另一个节点连上
    currentNode.next = currentNode.next.next;
    this.size--;
  }
}
```

### 数组中找数之和

#### 排序数组中的两个数字之和的下标

```js
// 输入一个递增排序的数组和一个值target,在数组中找出两个和为target的数字并返回它们的下标
// 提示：
// 数组中有且只有一对符合要求
// 同时一个数字不能使用两次

// 示例：输入数组： [1,2,4,6,10],k的值为8 输出[1,3]

function twoSum4SortedArray(nums, target) {
  // prettier-ignore
  let left = 0, right = nums.length - 1; // 初始化指针left,right
  while (left < right && nums[left] + nums[right] != target) {
    if (nums[left] + nums[right] < target) {
      left++;
    } else {
      right--;
    }
  }
  return [left, right];
}
```

#### 非排序数组找两数之和

```js
function twoSum(nums, target) {
  let map = new Map(); // 用于，存储[nums[i],i]之间的关系
  for (let i = 0; i < nums.length; i++) {
    let expectValue = target - nums[i];
    // 先从map中找，是否存在指定值
    if (map.has(expectValue)) {
      // 如果有，直接返回与值相对于的下标
      return [map.get(expectValue), i];
    }
    // 存储[nums[i],i]之间的关系
    // 存 值=下标
    map.set(nums[i], i);
  }
  return null;
}
```

#### 数组中和为 target 的 3 个数字【难搞哦】

```js
// 输入一个数组，找出数组中所有和为target的3个数字的三元组
// 提示：
// 返回值不得包含重复的三元组

// 示例：输入数组： [-1,0,1,2,-1,-4],target的值为0 输出[[-1,0,1],[-1,-1,2]]

function threeSum(nums, target) {
  let result = [];
  if (nums.length < 3) return [];

  // 人工对数据进行排序处理
  nums.sort((a, b) => a - b);

  let i = 0;
  while (i < nums.length - 2) {
    twoSum(nums, i, target, result);
    let temp = nums[i];
    // 剔除，重复元祖中第一个数值
    while (i < nums.length && nums[i] == temp) i++;
  }
  return result;
}

function twoSum(nums, i, target, result) {
  // 初始化指针left,right
  // prettier-ignore
  let left = i + 1, right = nums.length - 1;

  while (left < right) {
    // 求和
    let sum = nums[i] + nums[left] + nums[right];
    // 指针移动过程 (if/else)
    if (sum === target) {
      result.push([nums[i], num[left], nums[right]]);

      let temp = nums[left];
      // 剔除，重复元祖第二个数值
      while (nums[left] === temp && left < right) left++;
    } else if (sum < 0) {
      left++;
    } else {
      right--;
    }
  }
}
```

### N 进制加法

```js
// 二进制加法
// Nsum('10','01',2)
// 结果为 11
// 十进制加法(十进制大数相加)
// Nsum('7','8',10)
// 结果为 15

// 原理：
// 1. 从数据尾部开始遍历
// 2. 通过字符串减法，获取对应位置的值
// 3. 对应位置数相加，+ 进位
// 4. 当前位置的值，进位的值
// 循环遍历
// 5. 遍历完成后是否还存在进位
function Nsum(a, b, n) {
  let result = ''; // 用来存储结果
  let i = a.length - 1; // 是为了倒着遍历
  let j = b.length - 1; // 是为了倒着遍历
  let carry = 0; // 进位

  while (i >= 0 || j >= 0) {
    /*这个减法有意思，会直接计算出来字符串与字符串的差值后的整数 */
    let digitA = i >= 0 ? a[i--] - '0' : 0;
    let digitB = j >= 0 ? b[j--] - '0' : 0;
    let sum = digitA + digitB + carry; // 对应位数之和 + 进位
    carry = sum >= n ? 1 : 0; // 是否有进位
    sum = sum >= n ? sum - n : sum; // 去掉进位后该位置的值
    result = sum + result;
  }
  // 最后是否有进位
  if (carry) {
    result = '1' + result;
  }
  return result;
}

Nsum('10', '01', 2);
```

### 只出现一次的数字

#### 某个元素仅出现 一次 外，其余每个元素都恰出现 N 次(看不懂)

```js
// 出现2次，找出现一次的 singleNumber([1,1,2,2,3],2); 结果为 3
// 出现3次，找出现一次的 singleNumber([1,1,1,2,2,2,3],3) 结果为 3
// 同理其他
function singleNumber(nums, n) {
  // 构建一个用于存储数组所有数字位数之和的数组
  let bitSums = new Array(32).fill(0);
  for (let num of nums) {
    for (let i = 0; i < 32; i++) {
      // 求num在i位置的位数，并将其与指定位置的位数相加
      bitSums[i] += (num >> (31 - i)) & 1;
    }
  }
  let result = 0;
  for (let i = 0; i < 32; i++) {
    //从最地位(0)位开始遍历
    result = (result << 1) + (bitSums[i] % n);
  }
  return result;
}
```

#### 某个元素仅出现 一次 外，其余每个元素都恰出现 2 次的另外解法

```js
function singleNumber(nums) {
  let result = 0;
  for (let i of nums) {
    result ^= i;
    console.log(i, result);
  }
  return result;
}

singleNumber([1, 3, 1, 2, 2], 2);

// 过程如下：
// 1 001
// 1 001
// 2 011
// 2 011
// 3 111 -> 111
```

### fibonic

斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……

#### 常规方式

```js
function fibonacci(n) {
  if (n <= 1) return 1;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
// fibonacci(1000) //  浏览器卡死
```

#### 尾调用方式

原理： 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了

```js
// 执行顺序
// 将 _next的结果作为fibonacci的值
function fibonacci(n, pre = 1, next = 1) {
  if (n <= 1) return next;
  const _pre = next; // 移动位置
  const _next = next + pre;
  return fibonacci(n - 1, _pre, _next /*值放到这里 */);
  // 上面三行等价于下面一行
  // return fibonacci(n - 1, next, next + pre);
}

fibonacci(4);
// 执行过程分析
// 4 fibonacci(3, 1, 2)
// 3 fibonacci(2, 2, 3)
// 2 fibonacci(1, 3, 5)
// 1 return 5
```

#### 迭代方式

### 阶乘

#### 普通递归

```js
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5); // 120
```

#### 尾调用递归

```js
// 尾调用是倒着处理的
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total /*值放到这里，算法在这里 */); // 尾部返回函数
}

factorial(5, 1); // 120
```

## 五分钟学习算法

<a href="https://www.jianshu.com/p/d13fcada7c2d" target="_blank" >链接</a>

## 其他算法

<a href="https://juejin.cn/post/7095201687421321224#heading-0" target="_blank" >待爬取</a>

### diffTwoDeps

```js
const diffTwoDeps = (deps1?: DependencyList, deps2?: DependencyList) => {
  //Let's do a reference equality check on 2 dependency list.
  //If deps1 is defined, we iterate over deps1 and do comparison on each element with equivalent element from deps2
  //As this func is used only in this hook, we assume 2 deps always have same length.
  return deps1
    ? deps1.map((_ele, idx) => (!Object.is(deps1[idx], deps2?.[idx]) ? idx : -1)).filter((ele) => ele >= 0)
    : // prettier-ignore
    deps2 ? deps2.map((_ele, idx) => idx) : [];
};
```

### Object.is

```js
if (!Object.is) {
  Object.defineProperty(Object, 'is', {
    value: function (x, y) {
      // SameValue algorithm
      if (x === y) {
        // return true if x and y are not 0, OR
        // if x and y are both 0 of the same sign.
        // This checks for cases 1 and 2 above.
        // 相等的情况，需要处理正负零
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // return true if both x AND y evaluate to NaN.
        // The only possibility for a variable to not be strictly equal to itself
        // is when that variable evaluates to NaN (example: Number.NaN, 0/0, NaN).
        // This checks for case 3.
        // 不相等，排除NaN
        return x !== x && y !== y;
      }
    },
  });
}

//
```

### 三点是否共线

```js
// 三点是否共线可以通过判断斜率来判断：
// 设有 p1,p2,q三点，判断三点是否共线:
// 公式：

// k1 = (p2.y - p1.y)/(p2.x - p1.x)

// k2 = (q.y - p1.y)/(q.x - p1.x)

// 如果k1 === k2就表示三点共线

function isOnLine(p1, p2, q) {
  return (p2.y - p1.y) / (p2.x - p1.x) === (q.y - p1.y) / (q.x - p1.x);
  // 如果，指定q是否在线段内部，还需要判断q的范围大小
}
```

## 参考链接

1. <a href="https://www.cnblogs.com/pangqianjin/p/14998643.html" target="_blank" >JavaScript 手写几种常见的排序算法：冒泡、选择、插入、希尔、归并、快排</a>
2. <a href="https://blog.csdn.net/qq_44433261/article/details/117235740" target="_blank" >排序动画</a>
3. <a href="https://wenku.baidu.com/view/7f84552a6f85ec3a87c24028915f804d2b16878c.html" target="_blank" >分治思想——精选推荐</a>
4. <a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B3%95/9763353?fr=aladdin" target="_blank" >归并排序法 百度百科</a>
5. <a href="https://blog.csdn.net/Sherlook_Holmes/article/details/120584469" target="_blank" >（含动画演示）搞懂归并排序 一学就会</a>
6. <a href="https://www.jianshu.com/u/c6ad3f2ed2d6" target="_blank" >五分钟学算法(PPT 做的 gif)</a>
7. <a href="https://wenku.baidu.com/view/8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html" target="_blank" >Promise.resolve（）详解</a>
8. <a href="https://juejin.cn/post/7206912311562174523#heading-79" target="_blank" >22023 面试真题之手写&代码运行篇</a>
9. <a href="/#/post/2023-03-062023js" target="_blank" >/#/post/2023-03-062023js</a>
10. <a href="/#/post/2023-03-07按位操作" target="_blank" >/#/post/2023-03-07 按位操作</a>
11. <a href="/#/post/2023-03-09defineProperty" target="_blank" >/#/post/2023-03-09defineProperty</a>
